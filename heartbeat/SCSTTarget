#!/bin/bash
#
# SCSTTarget
#
# Description: Exports and manages SCST targets.
#
# Author:      Andreas Kurz
#
# License:     GNU General Public License (GPL)
#
# (c) 2015     Andreas Kurz <andreas.kurz AT gmail DOT com>
#
# This resource agent is derived from the iSCSITarget resource
# agent, which itself is made available to the public under the
# following copyright:
#
# (c) 2009-2010 Florian Haas, Dejan Muhamedagic,
#               and Linux-HA contributors
#
# See usage() function below for more details ...
#
#######################################################################
# Initialization:
: ${OCF_FUNCTIONS_DIR=${OCF_ROOT}/lib/heartbeat}
. ${OCF_FUNCTIONS_DIR}/ocf-shellfuncs

# Defaults
# Set the iSCSI fabric as default 
OCF_RESKEY_fabric_default="iscsi"
: ${OCF_RESKEY_fabric=${OCF_RESKEY_fabric_default}}

# Listen on 0.0.0.0 by default
OCF_RESKEY_iscsi_portals_default="0.0.0.0"
: ${OCF_RESKEY_iscsi_portals=${OCF_RESKEY_iscsi_portals_default}}

# For convenience
SCST_BASE="/sys/kernel/scst_tgt"
FABRIC_BASE="${SCST_BASE}/targets/${OCF_RESKEY_fabric}"
#######################################################################

meta_data() {
	cat <<END
<?xml version="1.0"?>
<!DOCTYPE resource-agent SYSTEM "ra-api-1.dtd">
<resource-agent name="SCSTTarget" version="0.0.2">
<version>0.0.2</version>

<longdesc lang="en">
Manages SCST targets. A target is a daemon that speaks
 a specific protocol and exports a collection of Logical Units (LUs) .
</longdesc>
<shortdesc lang="en">SCST target export agent</shortdesc>

<parameters>
<parameter name="fabric" required="0" unique="0">
<longdesc lang="en">
The SCST target supports several fabric types. Must be one of "iscsi" or
"qla2xxx". If unspecified, "iscsi" is used.
</longdesc>
<shortdesc lang="en">Specifies the type of fabric</shortdesc>
<content type="string" default="${OCF_RESKEY_fabric_default}"/>
</parameter>

<parameter name="id" required="1" unique="1">
<longdesc lang="en">
ISCSI targets use an iSCSI Qualified Name (IQN). Should follow the conventional
"iqn.yyyy-mm.&lt;reversed domain name&gt;[:identifier]" syntax.
FC targets use a World Wide Port Name (WWPN). Each World Wide Name (WWN)
 is an 8 byte number derived from an IEEE OUI and vendor-supplied information.
For FC targets it is supported to add a white-space separated list of WWPNs
(e.g. all ports on a multi-link HBA)
</longdesc>
<shortdesc lang="en">Target id (IQN or WWPN)</shortdesc>
<content type="string" />
</parameter>

<parameter name="iscsi_portals" required="0" unique="0">
<longdesc lang="en">
White space separated list of iSCSI network portal addresses.
If unset, the default is to create one portal that listens on
${OCF_RESKEY_iscsi_portals_default}.
</longdesc>
<shortdesc lang="en">iSCSI portal addresses</shortdesc>
<content type="string" default="${OCF_RESKEY_iscsi_portals_default}"/>
</parameter>

<parameter name="additional_parameters" required="0" unique="0">
<longdesc lang="en">
Additional target parameters. A space-separated list of "name=value"
pairs which will be passed through to the SCST targets management
interface. The supported parameters are implementation
dependent. Neither the name nor the value may contain whitespace.
</longdesc>
<shortdesc lang="en">List of SCST target parameters</shortdesc>
<content type="string" />
</parameter>

</parameters>

<actions>
<action name="start"        timeout="10" />
<action name="stop"         timeout="10" />
<action name="status"       timeout="10" interval="10" depth="0" />
<action name="monitor"      timeout="10" interval="10" depth="0" />
<action name="meta-data"    timeout="5" />
<action name="validate-all"   timeout="10" />
</actions>
</resource-agent>
END
}

#######################################################################

SCSTTarget_usage() {
	cat <<END
usage: $0 {start|stop|status|monitor|validate-all|meta-data}

Expects to have a fully populated OCF RA-compliant environment set.
END
}

SCSTTarget_start() {
    SCSTTarget_monitor
    if [ $? =  $OCF_SUCCESS ]; then
	return $OCF_SUCCESS
    fi

    local param
    local name
    local value
    local initiator
    local portal
    local mod
    local other_mods
    local ids

    # Load core modules
    for mod in scst scst_vdisk scst_disk; do
       ocf_run -q modprobe -s $mod || {
          ocf_log err "Unable to load ${mod} module";
          return $OCF_ERR_INSTALLED
       }
       ocf_log debug "${OCF_RESOURCE_INSTANCE}: ${mod} module loaded."
    done

    # Intel Nehalem processor supports hardware accelerated crc32
    # algorithm with the new CRC32 instruction in SSE 4.2 instruction set.
    if grep -q ' sse4_2 ' /proc/cpuinfo; then
        other_mods="crc32c-intel"
    else
        other_mods="crc32"
    fi

    # Load extra modules
    for mod in $other_mods; do
      ocf_run -q modprobe -s $mod || {
         ocf_log err "Unable to load ${mod} module";
         return $OCF_ERR_INSTALLED
      }
      ocf_log debug "${OCF_RESOURCE_INSTANCE}: ${mod} module loaded."
    done

    # Create the target and portals
    case ${OCF_RESKEY_fabric} in
        iscsi)
            # Initiate the fabric if needed
            if [ ! -d "${FABRIC_BASE}" ]; then
                ocf_run -q modprobe -s  iscsi_scst || {
                   ocf_log err "Unable to load iscsi_scst  module";
                   return $OCF_ERR_INSTALLED
                }
                ocf_log debug "${OCF_RESOURCE_INSTANCE}: iscsi_scst module loaded."
            fi

            # Create the target
            if [ ! -d "${FABRIC_BASE}/${OCF_RESKEY_id}" ]; then
                echo "add_target ${OCF_RESKEY_id}" >${FABRIC_BASE}/mgmt || {
                    ocf_log err "Unable to create target ${OCF_RESKEY_id}.";
                    exit $OCF_ERR_GENERIC
                }
                ocf_log debug "${OCF_RESOURCE_INSTANCE}: iSCSI target ${OCF_RESKEY_id} initialized"
            fi

            # Define allowed portals
            if [ "${OCF_RESKEY_iscsi_portals}" != "${OCF_RESKEY_iscsi_portals_default}" ]; then
                for portal in ${OCF_RESKEY_iscsi_portals}; do
                   if ! grep -qE "${portal}$" ${FABRIC_BASE}/${OCF_RESKEY_id}/allowed_portal* ; then
                       echo "add_target_attribute ${OCF_RESKEY_id} allowed_portal ${portal}" >${FABRIC_BASE}/mgmt || {
                           ocf_log err "Unable to set allowed portal ${portal} on target ${OCF_RESKEY_id}.";
                           exit $OCF_ERR_GENERIC
                       }
                   fi
                done
                ocf_log debug "${OCF_RESOURCE_INSTANCE}: Allowed portals on target ${OCF_RESKEY_id} are set to: ${OCF_RESKEY_iscsi_portals}."
            fi

        ;;
        qla2xxx)
            # Initiate the fabric if needed
            if [ ! -d /sys/kernel/config/target/${OCF_RESKEY_fabric} ]; then
                for mod in fc qla2xxx; do
                   ocf_run -q modprobe -s  tcm_${mod} || {
                      ocf_log err "Unable to load tcm_${mod} module";
                      return $OCF_ERR_INSTALLED
                   }
                   ocf_log debug "${OCF_RESOURCE_INSTANCE}: tcm_${mod} module loaded."
                   ocf_run -q mkdir -p /sys/kernel/config/target/${mod} || {
                      ocf_log err "Unable to create $mod target configfs entry";
                      return $OCF_ERR_INSTALLED
                   }
                   ocf_log debug "${OCF_RESOURCE_INSTANCE}: $mod configfs entry created"
                done
            fi
            # no nice lio-utils support for FC targets
            for ids in ${OCF_RESKEY_id}; do
                ocf_run -q mkdir -p /sys/kernel/config/target/qla2xxx/${ids}/tpgt_1 || {
                    ocf_log err "Unable to initialize FC target ${ids}";
                    exit $OCF_ERR_GENERIC
                }
                ocf_log debug "${OCF_RESOURCE_INSTANCE}: FC target ${ids} initialized"
            done
        ;;
    esac

    # Set specific target parameters for the target
    for param in ${OCF_RESKEY_additional_parameters}; do
	name=${param%=*}
	value=${param#*=}
        for ids in ${OCF_RESKEY_id}; do
	    if [ -e ${FABRIC_BASE}/${ids}/${name} ]; then
	        echo "${value}" >"${FABRIC_BASE}/${ids}/${name}" || exit $OCF_ERR_GENERIC
	    else
	        ocf_log warn "Unsupported ${OCF_RESKEY_fabric} target parameter ${name}: will be ignored."
	    fi
        done
    done
    ocf_log debug "${OCF_RESOURCE_INSTANCE}: Set specific parameter ${OCF_RESKEY_additional_parameters} for target ${OCF_RESKEY_id}"

    # SCST targets must have a LUN 0 - create a dummy on target creation.
    # Put LUN 0 in the target default group.
    if [ ! -L "${SCST_BASE}/handlers/vdisk_nullio/dummy" ]; then
        echo "add_device dummy dummy=1;size_mb=1;read_zero=1" >${SCST_BASE}/handlers/vdisk_nullio/mgmt || {
            ocf_log err "Unable to create dummy device for LUN 0 on target ${OCF_RESKEY_id}.";
            exit $OCF_ERR_GENERIC
        }
    fi
    for ids in ${OCF_RESKEY_id}; do
        # Add dummy LUN 0 to the target if it is not already available.
        if [ ! -d "${FABRIC_BASE}/${ids}/luns/0" ]; then
            echo "add dummy 0" >${FABRIC_BASE}/${ids}/luns/mgmt || {
                ocf_log err "Unable to add dummy LUN 0 to target ${OCF_RESKEY_id}.";
                exit $OCF_ERR_GENERIC
            }
        fi
        # Check if LUN 0 is exported but is _not_ our dummy device
        [ "$(cat ${FABRIC_BASE}/${ids}/luns/0/device/prod_id 2>/dev/null)" = "dummy" ] || {
            ocf_log err "The LUN 0 exported in the default group of target ${OCF_RESKEY_id} is not the expected dummy device.";
            exit $OCF_ERR_GENERIC
        }
    done
    ocf_log debug "${OCF_RESOURCE_INSTANCE}: Added dummy LUN 0 to target ${OCF_RESKEY_id}"

    # Enable this specific target
    for ids in ${OCF_RESKEY_id}; do
        echo "1" >"${FABRIC_BASE}/${ids}/enabled" || {
            ocf_log err "Unable to enable target ${OCF_RESKEY_id}.";
            exit $OCF_ERR_GENERIC
        }
        ocf_log debug "${OCF_RESOURCE_INSTANCE}: Enabled iSCSI target ${OCF_RESKEY_id}"
    done

    # Be sure all Targets are finally enabled
    echo "1" >"${FABRIC_BASE}/enabled" || {
        ocf_log err "Unable to enable ${OCF_RESKEY_fabric} fabric.";
        exit $OCF_ERR_GENERIC
    }
    ocf_log debug "${OCF_RESOURCE_INSTANCE}: Enabled ${OCF_RESKEY_fabric} fabric."

    return $OCF_SUCCESS
}

SCSTTarget_stop() {
    local rc
    local session
    SCSTTarget_monitor
    if [ $? =  $OCF_SUCCESS ]; then
	case $OCF_RESKEY_fabric in
	    iscsi)
                # The target dir is not available? Consider it stopped.
                if [ -d "${FABRIC_BASE}/${OCF_RESKEY_id}" ]; then
                    # Disable the target to prevent new connections
                    echo "0" >"${FABRIC_BASE}/${ids}/enabled" || {
                        ocf_log err "Unable to disable target ${OCF_RESKEY_id}.";
                        exit $OCF_ERR_GENERIC
                    }
                    ocf_log debug "${OCF_RESOURCE_INSTANCE}: Disabled iSCSI target ${OCF_RESKEY_id}"

                    # Forcefully close all initiator sessions
                    for session in $(ls -1 "${FABRIC_BASE}/${OCF_RESKEY_id}/sessions"); do
                        echo 1 >"${session}/force_close"
                        ocf_log warn "Forcefully closed session from initiator ${session}.";
                    done

                    # Delete the target
                    echo "del_target ${OCF_RESKEY_id}" >${FABRIC_BASE}/mgmt || {
                        ocf_log err "Unable to delete target ${OCF_RESKEY_id}.";
                        exit $OCF_ERR_GENERIC
                    }
                    ocf_log debug "${OCF_RESOURCE_INSTANCE}: iSCSI target ${OCF_RESKEY_id} deleted"
                fi
		;;
	    qla2xxx)
                # Unfortunately older targetcli has no meaningfull
                # return codes
                for ids in ${OCF_RESKEY_id}; do
	            echo -e "/qla2xxx delete ${ids}\nexit\nexit" | targetcli
		    # This can take some seconds,
                    # spin on monitor
                done
                rc=$OCF_SUCCESS
                while [ $rc = $OCF_SUCCESS ]; do
		    sleep 2
                    SCSTTarget_monitor
		    rc=$?
                done
		;;
	esac
    fi
    # If there is no subdirectory in the fabric base dir, no target of
    # this type is configured.
    # Disable this type of fabric after its last target was disabled.
    if [ $(find ${FABRIC_BASE} -mindepth 1 -maxdepth 1 -type d | wc -l) -eq 0 ]; then
        echo "0" >"${FABRIC_BASE}/enabled" || {
            ocf_log err "Unable to disable fabric of type ${OCF_RESKEY_fabric}.";
            exit $OCF_ERR_GENERIC
        }
    ocf_log debug "${OCF_RESOURCE_INSTANCE}: disabled ${OCF_RESKEY_fabric} fabric after last target was disabled."
    fi

    return $OCF_SUCCESS
}

SCSTTarget_monitor() {
    declare -a targets=( $(echo ${OCF_RESKEY_id}) )
    local index=${#targets[@]}
    local ids
    local path

    # check if the targets are globally disabled -
    # and if the sysfs entry is here at all.
    # in either case, consider ist stopped
    if [ -e ${FABRIC_BASE}/enabled ]; then
        [ `cat ${FABRIC_BASE}/enabled` -eq 1 ] || return $OCF_NOT_RUNNING
    else
        return $OCF_NOT_RUNNING
    fi

    # if we have no sysfs entry for the individual target,
    # it's definitely stopped.
    for ids in ${OCF_RESKEY_id}; do
        [ -d ${FABRIC_BASE}/${ids} ] || (( index-- ))
    done
    # check if no target is here
    if [ $index -eq 0 ]; then
         return $OCF_NOT_RUNNING
    fi

    # if the target is there, but it is not enabled, then
    # we also consider it stopped
    for ids in ${OCF_RESKEY_id}; do
        path="${FABRIC_BASE}/${ids}/enable"
        if [ -e ${path} ]; then
            [ `cat ${path}` -eq 1 ] || (( index-- ))
        fi
    done
    # check if every single target is disabled
    if [ $index -eq 0 ]; then
        return $OCF_NOT_RUNNING
    fi

    # catch only partly configured target groups
    if [[ $index -ne ${#targets[@]} ]]; then
        case $__OCF_ACTION in
            monitor|start)
                # only partly running? consider it not running,
                # so rest gets started
                return $OCF_NOT_RUNNING
                ;;
            stop)
                # so its still not all stopped, consider it running
                return $OCF_SUCCESS
                ;;
        esac
    fi

    return $OCF_SUCCESS
}

SCSTTarget_validate() {
    # Do we have all required variables?
    local required_vars
    case $OCF_RESKEY_fabric in
	iscsi|qla2xxx)
	    required_vars="id"
	;;
    esac
    for var in ${required_vars}; do
	param="OCF_RESKEY_${var}"
	if [ -z "${!param}" ]; then
	    ocf_log error "Missing resource parameter \"${var}\"!"
	    exit $OCF_ERR_CONFIGURED
	fi
    done

    # Is the configured implementation supported?
    case "$OCF_RESKEY_fabric" in
	"iscsi")
	    ;;
	*)
	    ocf_log error "Unsupported SCST fabric type \"${OCF_RESKEY_fabric}\"!"
	    exit $OCF_ERR_CONFIGURED
	    ;;
    esac

    # Do we have any configuration parameters that the current
    # implementation does not support?
    local unsupported_params
    local var
    local envar
    case $OCF_RESKEY_fabric in
	iscsi|qla2xxx)
	    unsupported_params="tid incoming_username incoming_password"
	    ;;
    esac
    for var in ${unsupported_params}; do
	envar=OCF_RESKEY_${var}
	defvar=OCF_RESKEY_${var}_default
	if [ -n "${!envar}" ]; then
            if  [[ "${!envar}" != "${!defvar}" ]];then
                    case "$__OCF_ACTION" in
                        start|validate-all)
                          ocf_log warn "Configuration parameter \"${var}\"" \
                            "is not supported by by the \"${OCF_RESKEY_fabric}\" fabric" \
                            "and will be ignored." ;;
                    esac
            fi
	fi
    done

    if ! ocf_is_probe; then
        # Do we have all required binaries?
	case $OCF_RESKEY_fabric in
	    iscsi|qla2xxx)
		check_binary modprobe
		check_binary rmmod
		check_binary find
		;;
	esac
    fi

    return $OCF_SUCCESS
}


case $1 in
  meta-data)
	meta_data
	exit $OCF_SUCCESS
	;;
  usage|help)
	SCSTTarget_usage
	exit $OCF_SUCCESS
	;;
esac

# Everything except usage and meta-data must pass the validate test
SCSTTarget_validate

case $__OCF_ACTION in
start)		SCSTTarget_start;;
stop)		SCSTTarget_stop;;
monitor|status)	SCSTTarget_monitor;;
validate-all)	;;
*)		SCSTTarget_usage
		exit $OCF_ERR_UNIMPLEMENTED
		;;
esac
rc=$?
ocf_log debug "${OCF_RESOURCE_INSTANCE} $__OCF_ACTION : $rc"
exit $rc
