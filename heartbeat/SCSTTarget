#!/bin/bash
#
# SCSTTarget
#
# Description: Exports and manages SCST targets.
#
# Author:      Andreas Kurz
#
# License:     GNU General Public License (GPL)
#
# (c) 2015     Andreas Kurz <andreas.kurz AT gmail DOT com>
#
# This resource agent is derived from the iSCSITarget resource
# agent, which itself is made available to the public under the
# following copyright:
#
# (c) 2009-2010 Florian Haas, Dejan Muhamedagic,
#               and Linux-HA contributors
#
# See usage() function below for more details ...
#
#######################################################################
# Initialization:
: ${OCF_FUNCTIONS_DIR=${OCF_ROOT}/lib/heartbeat}
. ${OCF_FUNCTIONS_DIR}/ocf-shellfuncs

# Defaults
# Set the iSCSI fabric as default 
OCF_RESKEY_fabric_default="iscsi"
: ${OCF_RESKEY_fabric=${OCF_RESKEY_fabric_default}}

# Listen on 0.0.0.0 by default
OCF_RESKEY_iscsi_portals_default="0.0.0.0"
: ${OCF_RESKEY_iscsi_portals=${OCF_RESKEY_iscsi_portals_default}}

# for debugging this RA
DEBUG_LOG_DIR=/tmp/SCSTTarget.ocf.ra.debug
DEBUG_LOG=$DEBUG_LOG_DIR/${OCF_RESOURCE_INSTANCE}.log
USE_DEBUG_LOG=false
ls_stat_is_dir_0700_root() {
    set -- $(command ls -ldn "$1" 2>/dev/null);
    [[ $1/$3 = drwx?-??-?/0 ]]
}
# try to avoid symlink vuln.
if ls_stat_is_dir_0700_root $DEBUG_LOG_DIR &&
    [[ -w "$DEBUG_LOG" && ! -L "$DEBUG_LOG" ]]
then
    USE_DEBUG_LOG=true
    exec 9>>"$DEBUG_LOG"
    date >&9
    echo "$*" >&9
    env | grep OCF_ | sort >&9
else
    exec 9>/dev/null
fi
# end of debugging aid

# For convenience
SCST_BASE="/sys/kernel/scst_tgt"
FABRIC_BASE="${SCST_BASE}/targets/${OCF_RESKEY_fabric}"
CRM_ATTR_TGT="${HA_SBIN_DIR}/crm_attribute --node ${HOSTNAME} --name local_${OCF_RESKEY_fabric}_targets --lifetime forever"

# Lockfile, to prevent races on multi-target setups
LOCKFILE=${HA_RSCTMP}/SCSTTarget.lock
#######################################################################

meta_data() {
	cat <<END
<?xml version="1.0"?>
<!DOCTYPE resource-agent SYSTEM "ra-api-1.dtd">
<resource-agent name="SCSTTarget" version="0.1.1">
<version>0.1.1</version>

<longdesc lang="en">
Manages SCST targets. A target is a daemon that speaks
 a specific protocol and exports a collection of Logical Units (LUs) .
</longdesc>
<shortdesc lang="en">SCST target export agent</shortdesc>

<parameters>
<parameter name="fabric" required="0" unique="0">
<longdesc lang="en">
The SCST target supports several fabric types. Must be one of "iscsi" or
"qla2xxx". If unspecified, "iscsi" is used.
</longdesc>
<shortdesc lang="en">Specifies the type of fabric</shortdesc>
<content type="string" default="${OCF_RESKEY_fabric_default}"/>
</parameter>

<parameter name="id" required="1" unique="1">
<longdesc lang="en">
ISCSI targets use an iSCSI Qualified Name (IQN). Should follow the conventional
"iqn.yyyy-mm.&lt;reversed domain name&gt;[:identifier]" syntax.
FC targets use a World Wide Port Name (WWPN). Each World Wide Name (WWN)
 is an 8 byte number derived from an IEEE OUI and vendor-supplied information.
For FC targets it is supported to add a white-space separated list of WWPNs
(e.g. all ports on a multi-link HBA)
</longdesc>
<shortdesc lang="en">Target id (IQN or WWPN)</shortdesc>
<content type="string" />
</parameter>

<parameter name="iscsi_portals" required="0" unique="0">
<longdesc lang="en">
White space separated list of iSCSI network portal addresses.
If unset, the default is to create one portal that listens on
${OCF_RESKEY_iscsi_portals_default}.
</longdesc>
<shortdesc lang="en">iSCSI portal addresses</shortdesc>
<content type="string" default="${OCF_RESKEY_iscsi_portals_default}"/>
</parameter>

<parameter name="additional_parameters" required="0" unique="0">
<longdesc lang="en">
Additional target parameters. A space-separated list of "name=value"
pairs which will be passed through to the SCST targets management
interface. The supported parameters are implementation
dependent. Neither the name nor the value may contain whitespace.
</longdesc>
<shortdesc lang="en">List of SCST target parameters</shortdesc>
<content type="string" />
</parameter>

</parameters>

<actions>
<action name="start"        timeout="10" />
<action name="stop"         timeout="10" />
<action name="status"       timeout="10" interval="10" depth="0" />
<action name="monitor"      timeout="10" interval="10" depth="0" />
<action name="meta-data"    timeout="5" />
<action name="validate-all"   timeout="10" />
</actions>
</resource-agent>
END
}

#######################################################################

# Read the SCST sysfs attribute $1. See also scst/README for more information.
scst_sysfs_read() {
    local EAGAIN val

    EAGAIN="Resource temporarily unavailable"
    while true; do
        if val="$(LC_ALL=C cat "$1" 2>&1)"; then
            echo -n "${val%\[key\]}"
            return 0
	elif [ "${val/*: }" != "$EAGAIN" ]; then
            return 1
        fi
        sleep 1
    done
}

# Write $1 into the SCST sysfs attribute $2. See also scst/README for more
# information.
scst_sysfs_write() {
    local EAGAIN status

    EAGAIN="Resource temporarily unavailable"
    if status="$(LC_ALL=C; (echo -n "$1" > "$2") 2>&1)"; then
        return 0
    elif [ "${status/*: }" != "$EAGAIN" ]; then
        return 1
    fi
    scst_sysfs_read /sys/kernel/scst_tgt/last_sysfs_mgmt_res >/dev/null
}

SCSTTarget_usage() {
	cat <<END
usage: $0 {start|stop|status|monitor|validate-all|meta-data}

Expects to have a fully populated OCF RA-compliant environment set.
END
}

SCSTTarget_start() {
    SCSTTarget_monitor
    if [ $? =  $OCF_SUCCESS ]; then
	return $OCF_SUCCESS
    fi

    local param
    local name
    local value
    local initiator
    local portal
    local mod
    local other_mods
    local ids

    # Load core modules
    for mod in scst scst_vdisk scst_disk; do
       ocf_run -q modprobe -s $mod || {
          ocf_log err "Unable to load ${mod} module";
          return $OCF_ERR_INSTALLED
       }
       ocf_log debug "${OCF_RESOURCE_INSTANCE}: ${mod} module loaded."
    done

    # Intel Nehalem processor supports hardware accelerated crc32
    # algorithm with the new CRC32 instruction in SSE 4.2 instruction set.
    if grep -q ' sse4_2 ' /proc/cpuinfo; then
        other_mods="crc32c-intel"
    else
        other_mods="crc32"
    fi

    # Load extra modules
    for mod in $other_mods; do
      ocf_run -q modprobe -s $mod || {
         ocf_log err "Unable to load ${mod} module";
         return $OCF_ERR_INSTALLED
      }
      ocf_log debug "${OCF_RESOURCE_INSTANCE}: ${mod} module loaded."
    done

    # Wait for the lock to manage targets
    ocf_take_lock $LOCKFILE
    ocf_release_lock_on_exit $LOCKFILE

    # Create the target and portals
    case ${OCF_RESKEY_fabric} in
        iscsi)
            # Initiate the fabric if needed
            if [ ! -d "${FABRIC_BASE}" ]; then
                ocf_run -q modprobe -s  iscsi_scst || {
                   ocf_log err "Unable to load iscsi_scst  module";
                   return $OCF_ERR_INSTALLED
                }
                ocf_log debug "${OCF_RESOURCE_INSTANCE}: iscsi_scst module loaded."
            fi

            # Create the target
            if [ ! -d "${FABRIC_BASE}/${OCF_RESKEY_id}" ]; then
                scst_sysfs_write "add_target ${OCF_RESKEY_id}" ${FABRIC_BASE}/mgmt || {
                    ocf_log err "Unable to create target ${OCF_RESKEY_id}.";
                    exit $OCF_ERR_GENERIC
                }
                ocf_log debug "${OCF_RESOURCE_INSTANCE}: iSCSI target ${OCF_RESKEY_id} initialized"
            fi

            # Define allowed portals
            if [ "${OCF_RESKEY_iscsi_portals}" != "${OCF_RESKEY_iscsi_portals_default}" ]; then
                for portal in ${OCF_RESKEY_iscsi_portals}; do
                   if ! grep -qE "${portal}$" ${FABRIC_BASE}/${OCF_RESKEY_id}/allowed_portal* ; then
                       scst_sysfs_write "add_target_attribute ${OCF_RESKEY_id} allowed_portal ${portal}" ${FABRIC_BASE}/mgmt || {
                           ocf_log err "Unable to set allowed portal ${portal} on target ${OCF_RESKEY_id}.";
                           exit $OCF_ERR_GENERIC
                       }
                   fi
                done
                ocf_log debug "${OCF_RESOURCE_INSTANCE}: Allowed portals on target ${OCF_RESKEY_id} are set to: ${OCF_RESKEY_iscsi_portals}."
            fi

        ;;
        qla2xxx)
            # Initiate the fabric if needed
            if [ ! -d /sys/kernel/config/target/${OCF_RESKEY_fabric} ]; then
                for mod in fc qla2xxx; do
                   ocf_run -q modprobe -s  tcm_${mod} || {
                      ocf_log err "Unable to load tcm_${mod} module";
                      return $OCF_ERR_INSTALLED
                   }
                   ocf_log debug "${OCF_RESOURCE_INSTANCE}: tcm_${mod} module loaded."
                   ocf_run -q mkdir -p /sys/kernel/config/target/${mod} || {
                      ocf_log err "Unable to create $mod target configfs entry";
                      return $OCF_ERR_INSTALLED
                   }
                   ocf_log debug "${OCF_RESOURCE_INSTANCE}: $mod configfs entry created"
                done
            fi
            # no nice lio-utils support for FC targets
            for ids in ${OCF_RESKEY_id}; do
                ocf_run -q mkdir -p /sys/kernel/config/target/qla2xxx/${ids}/tpgt_1 || {
                    ocf_log err "Unable to initialize FC target ${ids}";
                    exit $OCF_ERR_GENERIC
                }
                ocf_log debug "${OCF_RESOURCE_INSTANCE}: FC target ${ids} initialized"
            done
        ;;
    esac

    # Set specific target parameters for the target
    for param in ${OCF_RESKEY_additional_parameters}; do
	name=${param%=*}
	value=${param#*=}
        for ids in ${OCF_RESKEY_id}; do
	    if [ -e ${FABRIC_BASE}/${ids}/${name} ]; then
	        scst_sysfs_write "${value}" "${FABRIC_BASE}/${ids}/${name}" || exit $OCF_ERR_GENERIC
	    else
	        ocf_log warn "Unsupported ${OCF_RESKEY_fabric} target parameter ${name}: will be ignored."
	    fi
        done
    done
    ocf_log debug "${OCF_RESOURCE_INSTANCE}: Set specific parameter ${OCF_RESKEY_additional_parameters} for target ${OCF_RESKEY_id}"

    # SCST targets must have a LUN 0 - create a dummy on target creation.
    # Put LUN 0 in the target default group.
    if [ ! -L "${SCST_BASE}/handlers/vdisk_nullio/LUN0_${OCF_RESKEY_fabric}" ]; then
        scst_sysfs_write "add_device LUN0_${OCF_RESKEY_fabric} dummy=1;size_mb=1" ${SCST_BASE}/handlers/vdisk_nullio/mgmt || {
            ocf_log err "Unable to create dummy device for LUN 0 on target ${OCF_RESKEY_id}.";
            exit $OCF_ERR_GENERIC
        }
        scst_sysfs_write "1" ${SCST_BASE}/handlers/vdisk_nullio/LUN0_${OCF_RESKEY_fabric}/read_zero || \
        ocf_log warn "Unable to enable read_zero option for dummy LUN 0 on target ${OCF_RESKEY_id}."
    fi
    for ids in ${OCF_RESKEY_id}; do
        # Add dummy LUN 0 to the target if it is not already available.
        if [ ! -d "${FABRIC_BASE}/${ids}/luns/0" ]; then
            scst_sysfs_write "add LUN0_${OCF_RESKEY_fabric} 0" ${FABRIC_BASE}/${ids}/luns/mgmt || {
                ocf_log err "Unable to add dummy LUN 0 to target ${OCF_RESKEY_id}.";
                exit $OCF_ERR_GENERIC
            }
        fi
        # Check if LUN 0 is exported but is _not_ our dummy device
        [ "$(scst_sysfs_read ${FABRIC_BASE}/${ids}/luns/0/device/prod_id)" = "LUN0_${OCF_RESKEY_fabric}" ] || {
            ocf_log err "The LUN 0 exported in the default group of target ${OCF_RESKEY_id} is not the expected dummy device.";
            exit $OCF_ERR_GENERIC
        }
    done
    ocf_log debug "${OCF_RESOURCE_INSTANCE}: Added dummy LUN 0 to target ${OCF_RESKEY_id}"

    # Enable this specific target
    for ids in ${OCF_RESKEY_id}; do
        scst_sysfs_write "1" "${FABRIC_BASE}/${ids}/enabled" || {
            ocf_log err "Unable to enable target ${OCF_RESKEY_id}.";
            exit $OCF_ERR_GENERIC
        }
        ocf_log debug "${OCF_RESOURCE_INSTANCE}: Enabled iSCSI target ${OCF_RESKEY_id}"
    done

    # Be sure all Targets are finally enabled
    scst_sysfs_write "1" "${FABRIC_BASE}/enabled" || {
        ocf_log err "Unable to enable ${OCF_RESKEY_fabric} fabric.";
        exit $OCF_ERR_GENERIC
    }
    ocf_log debug "${OCF_RESOURCE_INSTANCE}: Enabled ${OCF_RESKEY_fabric} fabric."

    # Write the local configured targets into CIB -
    # need this for ALUA TPGs
    ${CRM_ATTR_TGT} --update "${OCF_RESKEY_id}"

    return $OCF_SUCCESS
}

SCSTTarget_stop() {
    local rc
    local session
    local ids

    SCSTTarget_monitor
    if [ $? =  $OCF_SUCCESS ]; then
        # Wait for the lock to manage targets
        ocf_take_lock $LOCKFILE
        ocf_release_lock_on_exit $LOCKFILE
     
	case $OCF_RESKEY_fabric in
	    iscsi)
                for ids in ${OCF_RESKEY_id}; do
                    # The target dir is not available? Consider it stopped.
                    if [ -d "${FABRIC_BASE}/${ids}" ]; then
                        # Disable the target to prevent new connections
                        scst_sysfs_write "0" "${FABRIC_BASE}/${ids}/enabled" || {
                            ocf_log err "Unable to disable target ${OCF_RESKEY_id}.";
                            exit $OCF_ERR_GENERIC
                        }
                        ocf_log debug "${OCF_RESOURCE_INSTANCE}: Disabled iSCSI target ${OCF_RESKEY_id}"

                        # Forcefully close all initiator sessions
                        for session in $(ls -1 "${FABRIC_BASE}/${ids}/sessions"); do
                            scst_sysfs_write "1" "${FABRIC_BASE}/${ids}/sessions/${session}/force_close"
                            ocf_log warn "Forcefully closed session from initiator ${session}.";
                        done

                        # Delete the target
                        scst_sysfs_write "del_target ${ids}" ${FABRIC_BASE}/mgmt || {
                            ocf_log err "Unable to delete target ${ids}.";
                            exit $OCF_ERR_GENERIC
                        }
                        ocf_log debug "${OCF_RESOURCE_INSTANCE}: iSCSI target ${ids} deleted"
                    fi
                done
		;;
	    qla2xxx)
                # Unfortunately older targetcli has no meaningfull
                # return codes
                for ids in ${OCF_RESKEY_id}; do
	            echo -e "/qla2xxx delete ${ids}\nexit\nexit" | targetcli
		    # This can take some seconds,
                    # spin on monitor
                done
                rc=$OCF_SUCCESS
                while [ $rc = $OCF_SUCCESS ]; do
		    sleep 2
                    SCSTTarget_monitor
		    rc=$?
                done
		;;
	esac
    fi
    # If there is no subdirectory in the fabric base dir, no target of
    # this type is configured.
    # Disable this type of fabric after its last target was disabled,
    # and cleanup the dummy device.
    if [ $(find ${FABRIC_BASE} -mindepth 1 -maxdepth 1 -type d | wc -l) -eq 0 ]; then
        # Delete the device definition for dummy lun 0
        if [ -e "${SCST_BASE}/handlers/vdisk_nullio/LUN0_${OCF_RESKEY_fabric}" ]; then
            scst_sysfs_write "del_device LUN0_${OCF_RESKEY_fabric}" ${SCST_BASE}/handlers/vdisk_nullio/mgmt || {
                ocf_log err "Unable to delete dummy device LUN0_${OCF_RESKEY_fabric} from vdisk_nullio handler.";
                exit $OCF_ERR_GENERIC
            }
            ocf_log debug "${OCF_RESOURCE_INSTANCE}: removed dummy device LUN0_${OCF_RESKEY_fabric} from ${OCF_RESKEY_fabric} fabric after last target was disabled."
        fi
        # Disable the fabric
        scst_sysfs_write "0" "${FABRIC_BASE}/enabled" || {
            ocf_log err "Unable to disable fabric of type ${OCF_RESKEY_fabric}.";
            exit $OCF_ERR_GENERIC
        }
        ocf_log debug "${OCF_RESOURCE_INSTANCE}: disabled ${OCF_RESKEY_fabric} fabric after last target was disabled."
    fi

    # Cleanup information for ALUA on target stop
    ${CRM_ATTR_TGT} --delete

    return $OCF_SUCCESS
}

SCSTTarget_monitor() {
    declare -a targets=( $(echo ${OCF_RESKEY_id}) )
    local index=${#targets[@]}
    local ids
    local path

    # check if the targets are globally disabled -
    # and if the sysfs entry is here at all.
    # in either case, consider ist stopped
    ocf_log debug "${OCF_RESOURCE_INSTANCE}: Check if fabric of type ${OCF_RESKEY_fabric} is loaded and enabled.";
    if [ -e ${FABRIC_BASE}/enabled ]; then
        [ `scst_sysfs_read ${FABRIC_BASE}/enabled` -eq 1 ] || {
            ocf_log debug "Fabric of type ${OCF_RESKEY_fabric} not enabled.";
            return $OCF_NOT_RUNNING
        }
    else
        ocf_log debug "Fabric of type ${OCF_RESKEY_fabric} not loaded.";
        return $OCF_NOT_RUNNING
    fi

    ocf_log debug "${OCF_RESOURCE_INSTANCE}: Check if target(s) ${OCF_RESKEY_id} (type ${OCF_RESKEY_fabric}) is/are loaded and enabled.";
    # if we have no sysfs entry for the individual target,
    # it's definitely stopped.
    for ids in ${OCF_RESKEY_id}; do
        [ -d ${FABRIC_BASE}/${ids} ] || {
            (( index-- ));
            ocf_log debug "${OCF_RESOURCE_INSTANCE}: Target ${OCF_RESKEY_id} is not configured.";
        }
    done
    # check if no target is here
    if [ $index -eq 0 ]; then
        ocf_log debug "${OCF_RESOURCE_INSTANCE}: No target is configured.";
        return $OCF_NOT_RUNNING
    fi

    # if the target is there, but it is not enabled, then
    # we also consider it stopped
    for ids in ${OCF_RESKEY_id}; do
        path="${FABRIC_BASE}/${ids}/enabled"
        if [ -e ${path} ]; then
            [ `scst_sysfs_read ${path}` -eq 1 ] || {
                (( index-- ));
                ocf_log debug "${OCF_RESOURCE_INSTANCE}: Target ${OCF_RESKEY_id} is disabled.";
            }
        fi
    done
    # check if every single target is disabled
    if [ $index -eq 0 ]; then
        ocf_log debug "${OCF_RESOURCE_INSTANCE}: All targets are disabled.";
        return $OCF_NOT_RUNNING
    fi

    ocf_log debug "${OCF_RESOURCE_INSTANCE}: Catch the only partly configured/enabled targets" ;
    # catch only partly configured target groups
    if [[ $index -ne ${#targets[@]} ]]; then
        case $__OCF_ACTION in
            monitor|start)
                # only partly running? consider it not running,
                # so rest gets started
                return $OCF_NOT_RUNNING
                ;;
            stop)
                # so its still not all stopped, consider it running
                return $OCF_SUCCESS
                ;;
        esac
    fi

    return $OCF_SUCCESS
}

SCSTTarget_validate() {
    # Do we have all required variables?
    local required_vars
    case $OCF_RESKEY_fabric in
	iscsi|qla2xxx)
	    required_vars="id"
	;;
    esac
    for var in ${required_vars}; do
	param="OCF_RESKEY_${var}"
	if [ -z "${!param}" ]; then
	    ocf_log error "Missing resource parameter \"${var}\"!"
	    exit $OCF_ERR_CONFIGURED
	fi
    done

    # Is the configured implementation supported?
    case "$OCF_RESKEY_fabric" in
	"iscsi")
	    ;;
	*)
	    ocf_log error "Unsupported SCST fabric type \"${OCF_RESKEY_fabric}\"!"
	    exit $OCF_ERR_CONFIGURED
	    ;;
    esac

    # Do we have any configuration parameters that the current
    # implementation does not support?
    local unsupported_params
    local var
    local envar
    case $OCF_RESKEY_fabric in
	iscsi|qla2xxx)
	    unsupported_params="tid incoming_username incoming_password"
	    ;;
    esac
    for var in ${unsupported_params}; do
	envar=OCF_RESKEY_${var}
	defvar=OCF_RESKEY_${var}_default
	if [ -n "${!envar}" ]; then
            if  [[ "${!envar}" != "${!defvar}" ]];then
                    case "$__OCF_ACTION" in
                        start|validate-all)
                          ocf_log warn "Configuration parameter \"${var}\"" \
                            "is not supported by by the \"${OCF_RESKEY_fabric}\" fabric" \
                            "and will be ignored." ;;
                    esac
            fi
	fi
    done

    # Do we have all required binaries?
    case $OCF_RESKEY_fabric in
        iscsi|qla2xxx)
            check_binary modprobe
            check_binary rmmod
            check_binary find
        ;;
    esac

    return $OCF_SUCCESS
}


case $1 in
  meta-data)
	meta_data
	exit $OCF_SUCCESS
	;;
  usage|help)
	SCSTTarget_usage
	exit $OCF_SUCCESS
	;;
esac

# Everything except usage and meta-data must pass the validate test
SCSTTarget_validate

case $__OCF_ACTION in
start)		SCSTTarget_start;;
stop)		SCSTTarget_stop;;
monitor|status)	SCSTTarget_monitor;;
validate-all)	;;
*)		SCSTTarget_usage
		exit $OCF_ERR_UNIMPLEMENTED
		;;
esac
rc=$?
ocf_log debug "${OCF_RESOURCE_INSTANCE} $__OCF_ACTION : $rc"
exit $rc
