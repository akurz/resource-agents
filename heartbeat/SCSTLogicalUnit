#!/bin/bash
#
# SCSTLogicalUnit
#
# Description: Resource Agent for highly available SCSTLogicalUnits.
#              Requires installed SCST kernel module, utilities and
#              a running SCST target. 
#
# Author:      Andreas Kurz
#
# License:     GNU General Public License (GPL)
#
# (c) 2015     Andreas Kurz <andreas.kurz AT gmail DOT com>
#
# This resource agent is derived from the iSCSITarget resource
# agent, which itself is made available to the public under the
# following copyright:
#
# (c) 2009-2010 Florian Haas, Dejan Muhamedagic,
#               and Linux-HA contributors
#
# See usage() function below for more details ...
#
#######################################################################
# Initialization:
: ${OCF_FUNCTIONS_DIR=${OCF_ROOT}/lib/heartbeat}
. ${OCF_FUNCTIONS_DIR}/ocf-shellfuncs

# Defaults
# Set the iSCSI fabric as default 
OCF_RESKEY_fabric_default="iscsi"
: ${OCF_RESKEY_fabric=${OCF_RESKEY_fabric_default}}
# Set default t10_vend_id
OCF_RESKEY_vendor_id_default="STORCIUM"
: ${OCF_RESKEY_vendor_id=${OCF_RESKEY_vendor_id_default}}
# Set the default SCST device handler
OCF_RESKEY_device_handler_default="vdisk_fileio"
: ${OCF_RESKEY_device_handler=${OCF_RESKEY_device_handler_default}}
# By default no initiator is allowed to access a LU
OCF_RESKEY_allowed_initiators_default=""
: ${OCF_RESKEY_allowed_initiators=${OCF_RESKEY_allowed_initiators_default}}

# Use a default SCSI ID and SCSI SN that is unique across the cluster,
# and persistent in the event of resource migration.
# SCSI IDs are limited to 24 bytes. To have a reasonably unique
# default SCSI SN, use the first 24 bytes of an MD5 hash of
# OCF_RESKEY_target_id and $OCF_RESOURCE_INSTANCE
sn=`echo -n "${OCF_RESKEY_target_id} ${OCF_RESOURCE_INSTANCE}" | openssl md5 | sed -e 's/(stdin)= //'`
OCF_RESKEY_scsi_id_default="${sn:0:24}"
: ${OCF_RESKEY_scsi_id=${OCF_RESKEY_scsi_id_default}}
: ${OCF_RESKEY_vendor_specific_id=${OCF_RESKEY_scsi_id}}
# To have a reasonably unique default SCSI SN, use the first 8 bytes
# of an MD5 hash of of $OCF_RESOURCE_INSTANCE
OCF_RESKEY_scsi_sn_default=${sn:0:8}
: ${OCF_RESKEY_scsi_sn=${OCF_RESKEY_scsi_sn_default}}

# for debugging this RA
DEBUG_LOG_DIR=/tmp/SCSTLogicalUnit.ocf.ra.debug
DEBUG_LOG=$DEBUG_LOG_DIR/${OCF_RESOURCE_INSTANCE}.log
USE_DEBUG_LOG=false
ls_stat_is_dir_0700_root() {
    set -- $(command ls -ldn "$1" 2>/dev/null);
    [[ $1/$3 = drwx?-??-?/0 ]]
}
# try to avoid symlink vuln.
if ls_stat_is_dir_0700_root $DEBUG_LOG_DIR &&
    [[ -w "$DEBUG_LOG" && ! -L "$DEBUG_LOG" ]]
then
    USE_DEBUG_LOG=true
    exec 9>>"$DEBUG_LOG"
    date >&9
    echo "$*" >&9
    env | grep OCF_ | sort >&9
else
    exec 9>/dev/null
fi
# end of debugging aid

# For convenience
SCST_BASE="/sys/kernel/scst_tgt"
FABRIC_BASE="${SCST_BASE}/targets/${OCF_RESKEY_fabric}"

# Lockfile, for LUs starting in parallel
LOCKFILE=${HA_RSCTMP}/SCSTLogicalUnit.lock
#######################################################################

meta_data() {
	cat <<END
<?xml version="1.0"?>
<!DOCTYPE resource-agent SYSTEM "ra-api-1.dtd">
<resource-agent name="SCSTLogicalUnit" version="0.1.1">
<version>0.1.1</version>

<longdesc lang="en">
Manages a Logical Unit for a SCST target. A Logical unit is a subdivision of 
a Target, exported via a daemon that speaks a specific protocol.
</longdesc>
<shortdesc lang="en">Manages Logical Units (LUs) for SCST targets</shortdesc>

<parameters>
<parameter name="fabric" required="0" unique="1">
<longdesc lang="en">
The SCST target supports several fabric types. Must be one of "iscsi" or
"qla2xxx". If unspecified, "iscsi" is used.
</longdesc>
<shortdesc lang="en">The type of fabric</shortdesc>
<content type="string" default="${OCF_RESKEY_fabric_default}"/>
</parameter>

<parameter name="target_id" required="1" unique="1">
<longdesc lang="en">
A white-space separated list of targets this Logical Unit belongs to. 
For iSCSI targets this has to be the target iSCSI Qualified Name (IQN).
Fibre Channel (qla2xxx) targets use a World Wide Name (WWN) for
identification.
</longdesc>
<shortdesc lang="en">Target identifier</shortdesc>
<content type="string" />
</parameter>

<parameter name="lun" required="1" unique="1">
<longdesc lang="en">
The Logical Unit number (LUN) exposed to initiators.
</longdesc>
<shortdesc lang="en">Logical Unit number (LUN)</shortdesc>
<content type="integer" />
</parameter>

<parameter name="path" required="1" unique="1">
<longdesc lang="en">
The path to the block device or file to be exposed.
</longdesc>
<shortdesc lang="en">Block device (or file) path</shortdesc>
<content type="string" />
</parameter>

<parameter name="device_handler" required="0" unique="1">
<longdesc lang="en">
The SCST devive handler to be used for this Logical Unit.
The supported handlers for this RA are:
vdisk_fileio, vdisk_blockio, vcdrom, vdisk_nullio
</longdesc>
<shortdesc lang="en">SCST device handler</shortdesc>
<content type="string" default="${OCF_RESKEY_device_handler_default}"/>
</parameter>

<parameter name="scsi_id" required="0" unique="1">
<longdesc lang="en">
The SCSI ID to be configured for this Logical Unit. The default
is a hash of the target id and the resource name, truncated to 24 bytes.
</longdesc>
<shortdesc lang="en">SCSI ID</shortdesc>
<content type="string" default="${OCF_RESKEY_scsi_id_default}"/>
</parameter>

<parameter name="scsi_sn" required="0" unique="1">
<longdesc lang="en">
The SCSI serial number to be configured for this Logical Unit.
The default is a hash of the target id and the resource name,
truncated to 8 bytes.
</longdesc>
<shortdesc lang="en">SCSI serial number</shortdesc>
<content type="string" default="${OCF_RESKEY_scsi_sn_default}"/>
</parameter>

<parameter name="product_id" required="0" unique="1">
<longdesc lang="en">
The SCSI product ID to be configured for this Logical Unit.
</longdesc>
<shortdesc lang="en">SCSI product ID</shortdesc>
<content type="string" />
</parameter>

<parameter name="vendor_id" required="0" unique="1">
<longdesc lang="en">
The SCSI vendor ID to be configured for this Logical Unit.
</longdesc>
<shortdesc lang="en">SCSI vendor ID</shortdesc>
<content type="string" default="${OCF_RESKEY_vendor_id_default}"/>
</parameter>

<parameter name="vendor_specific_id" required="0" unique="1">
<longdesc lang="en">
The SCSI vendor specific ID to be configured for this Logical Unit.
It defaults to the same value as the SCSI serial id.
</longdesc>
<shortdesc lang="en">SCSI vendor specific ID</shortdesc>
<content type="string" default="${OCF_RESKEY_scsi_id_default}"/>
</parameter>

<parameter name="additional_parameters" required="0" unique="1">
<longdesc lang="en">
Additional LU parameters. A space-separated list of "name=value" pairs
which will be passed through to the targets management
interface. Neither the name nor the value may contain whitespace.
</longdesc>
<shortdesc lang="en">List of LU parameters</shortdesc>
<content type="string" />
</parameter>

<parameter name="allowed_initiators" required="0" unique="0">
<longdesc lang="en">
Allowed initiators. A space-separated list of initiators allowed to
connect to this lun. Initiators may be listed in any syntax
the target fabric allows. If this parameter is empty or
not set, access to this lun will not be allowed from any initiator.
</longdesc>
<shortdesc lang="en">List of initiators allowed to connect
to this lun.</shortdesc>
<content type="string" default="${OCF_RESKEY_allowed_initiators_default}"/>
</parameter>

<parameter name="alua_tpg" required="0" unique="0">
<longdesc lang="en">
White-space separated list of SCST Asymmetric Logical Unit Assignment
 (ALUA) target port group names.

SCSI-4 ALUA is a multipathing method that allows each target port to
manage access states and path attributes using an explict method, or
implicitly using target-side configFS operations.
</longdesc>
<shortdesc lang="en">SCST ALUA target port group name</shortdesc>
<content type="string"/>
</parameter>

</parameters>

<actions>
<action name="start"        timeout="60" />
<action name="stop"         timeout="60" />
<action name="promote"      timeout="60" />
<action name="demote"       timeout="60" />
<action name="notify"       timeout="60" />
<action name="stop"         timeout="120" />
<action name="monitor"      depth="0" timeout="20" interval="10" />
<action name="monitor"      depth="0" timeout="20" interval="20" role="Slave" />
<action name="monitor"      depth="0" timeout="20" interval="10" role="Master" />
<action name="reload"       timeout="10" />
<action name="status"       timeout="10" interval="10" depth="0" />
<action name="meta-data"    timeout="5" />
<action name="validate-all" timeout="10" />
</actions>
</resource-agent>
END
}

#######################################################################

SCSTLogicalUnit_usage() {
	cat <<END
usage: $0 {start|stop|promote|demote|notify|status|monitor|reload|validate-all|meta-data}

Expects to have a fully populated OCF RA-compliant environment set.
END
}

# Read the SCST sysfs attribute $1. See also scst/README for more information.
scst_sysfs_read() {
    local EAGAIN val

    EAGAIN="Resource temporarily unavailable"
    while true; do
        if val="$(LC_ALL=C cat "$1" 2>&1)"; then
            echo -n "${val%\[key\]}"
            return 0
	elif [ "${val/*: }" != "$EAGAIN" ]; then
            return 1
        fi
        sleep 1
    done
}

# Write $1 into the SCST sysfs attribute $2. See also scst/README for more
# information.
scst_sysfs_write() {
    local EAGAIN status

    EAGAIN="Resource temporarily unavailable"
    if status="$(LC_ALL=C; (echo -n "$1" > "$2") 2>&1)"; then
        return 0
    elif [ "${status/*: }" != "$EAGAIN" ]; then
        return 1
    fi
    scst_sysfs_read /sys/kernel/scst_tgt/last_sysfs_mgmt_res >/dev/null
}

update_alua_access_state() {
    local tpg="$1"
    local dev_group="${SCST_BASE}/device_groups/${OCF_RESOURCE_INSTANCE}"

    case $2 in
        standby)
            scst_sysfs_write "0" ${dev_group}/target_groups/${tpg}/preferred || {
                ocf_log err "ALUA - Unable to set preferred to 0 - TPG ${tpg}, device_group ${OCF_RESOURCE_INSTANCE}.";
                exit $OCF_ERR_GENERIC
            }
            scst_sysfs_write "standby" ${dev_group}/target_groups/${tpg}/state || {
                ocf_log err "ALUA - Unable to set state to standby - TPG ${tpg}, device_group ${OCF_RESOURCE_INSTANCE}.";
                exit $OCF_ERR_GENERIC
            }
            ocf_log debug "${OCF_RESOURCE_INSTANCE} - ALUA: TPG ${tpg} is standby/not preferred."
            ;;
        active)
            scst_sysfs_write "1" ${dev_group}/target_groups/${tpg}/preferred || {
                ocf_log err "ALUA - Unable to set preferred to 0 - TPG ${tpg}, device_group ${OCF_RESOURCE_INSTANCE}.";
                exit $OCF_ERR_GENERIC
            }
            scst_sysfs_write "active" ${dev_group}/target_groups/${tpg}/state || {
                ocf_log err "ALUA - Unable to set state to active - TPG ${tpg}, device_group ${OCF_RESOURCE_INSTANCE}.";
                exit $OCF_ERR_GENERIC
            }
            ocf_log debug "${OCF_RESOURCE_INSTANCE}: ALUA - TPG ${tpg} is active/preferred."
            ;;
    esac

    return $OCF_SUCCESS
}

update_master_score() {
    local score
    local index
    declare -a tpgs=( $(echo -n ${OCF_RESKEY_alua_tpg}) )
    score=0

    # We have an array with all TPGs, the left most
    # one receeives the highest score. TPGs must be named
    # like the node names in Pacemaker.
    for (( index = 0; index < ${#tpgs[@]}; index++ )); do
        if [ "${tpgs[$index]}" = "$HOSTNAME" ]; then
            score=$(( ( ${#tpgs[@]} - $index ) * 5 ));
            break
        fi
    done

    ocf_log debug "Setting master score to $score"
    if [ $score -gt 0 ]; then
	set_master_score $score
    else
	remove_master_score
    fi
}

set_master_score() {
    # Use quiet mode (-Q) to quench logging. Actual score updates
    # will get logged by attrd anyway
    ocf_run ${HA_SBIN_DIR}/crm_master -Q -l reboot -v $1
}

remove_master_score() {
    ocf_run ${HA_SBIN_DIR}/crm_master -l reboot -D
}

SCSTLogicalUnit_acls() {
    declare -a exports_del
    local export_full_path
    local exports
    local initiator
    local init_path
    local session
    local target

    # Don't manipulate anything during a probe
    ocf_is_probe && return $OCF_SUCCESS

    # Wait for the lock to manage lun exports and
    # ini_groups.
    ocf_take_lock $LOCKFILE
    ocf_release_lock_on_exit $LOCKFILE

    for target in ${OCF_RESKEY_target_id}; do
        ini_path="${FABRIC_BASE}/${target}/ini_groups"
        # Get all existing acls for this LUN, fill it in an array.
        exports_del=( $(ls -1d ${ini_path}/*/luns/${OCF_RESKEY_lun} 2>/dev/null | grep -Ev '/mgmt$' | tr '\n' ' ') )

        # Only need to add acls on start,monitor or reload
        case $__OCF_ACTION in
            monitor|start|reload)
                ocf_log debug "Updating allowed initiators for LUN ${OCF_RESKEY_lun}, target ${target}."
                # Create one initiator group per initiator.
                for initiator in ${OCF_RESKEY_allowed_initiators}; do
                    # Create the ini_group
                    if [ ! -d "${ini_path}/${initiator}" ]; then
                        scst_sysfs_write "create ${initiator}" ${ini_path}/mgmt || {
                            ocf_log err "Unable to create initiator group ${initiator} for target ${target}.";
                            exit $OCF_ERR_GENERIC
                        }
                        ocf_log debug "${OCF_RESOURCE_INSTANCE}: Created initiator group ${initiator} for target ${target}."
                    fi

                    # allow only one initiator
                    if [ ! -e "${ini_path}/${initiator}/initiators/${initiator}" ]; then
                        scst_sysfs_write "add ${initiator}" ${ini_path}/${initiator}/initiators/mgmt || {
                            ocf_log err "Unable to add initiator ${initiator} to group ${initiator} for target ${target}.";
                            exit $OCF_ERR_GENERIC
                        }
                        ocf_log debug "${OCF_RESOURCE_INSTANCE}: Allowed initiator ${initiator} to group ${initiator} for target ${target}."
                    fi
                    # delete all other initiators
                    for index in $(ls -1 ${ini_path}/${initiator}/initiators 2>/dev/null | grep -Ev "^(mgmt|${initiator})$" | tr '\n' ' '); do
                        scst_sysfs_write "del ${index}" ${ini_path}/${initiator}/initiators/mgmt || {
                            ocf_log err "Unable to delete initiator ${index} from group ${initiator} for target ${target}.";
                            exit $OCF_ERR_GENERIC
                        }
                        ocf_log debug "${OCF_RESOURCE_INSTANCE}: Removed initiator ${index} from group ${initiator} for target ${target}."
                    done

                    # Always add LUN 0 to the initiator group
                    if [ ! -d "${ini_path}/${initiator}/luns/0" ]; then
                        scst_sysfs_write "add LUN0_${OCF_RESKEY_fabric} 0" ${ini_path}/${initiator}/luns/mgmt || {
                            ocf_log err "Unable to export LUN0_${OCF_RESKEY_fabric} with LUN 0 via initiator group ${initiator} for target ${target}.";
                            exit $OCF_ERR_GENERIC
                        }
                        ocf_log debug "${OCF_RESOURCE_INSTANCE}: Exported LUN0_${OCF_RESKEY_fabric} lun 0 via initiator group ${initiator} for target ${target}."
                    fi

                    # Finally export the LU for this initiator
                    if [ ! -d "${ini_path}/${initiator}/luns/${OCF_RESKEY_lun}" ]; then
                        scst_sysfs_write "add ${OCF_RESOURCE_INSTANCE} ${OCF_RESKEY_lun}" ${ini_path}/${initiator}/luns/mgmt || {
                            ocf_log err "Unable to export ${OCF_RESOURCE_INSTANCE} whith LUN ${OCF_RESKEY_lun} via initiator group ${initiator} for target ${target}.";
                            exit $OCF_ERR_GENERIC
                        }
                        ocf_log debug "${OCF_RESOURCE_INSTANCE}: Exported ${OCF_RESOURCE_INSTANCE} with LUN ${OCF_RESKEY_lun} via initiator group ${initiator} for target ${target}."
                    fi

                    # Remove valid export from "clean-them-up"-array.
                    export_full_path="${ini_path}/${initiator}/luns/${OCF_RESKEY_lun}"
                    for index in ${!exports_del[@]}; do
                        if [ "${exports_del[$index]}" = "$export_full_path" ]; then
                        unset exports_del[$index]
                            break
                        fi
                    done
                done
                # Remove exports for the current LU, that are not allowed.
                ocf_log debug "Cleanup acls for LUN ${OCF_RESKEY_lun}, target ${target} ini_group ${OCF_RESOURCE_INSTANCE}."
                for exports in ${exports_del[@]}; do
                    if [ -d "${exports}" ]; then
                        # remove the lun from the ini_group
                        scst_sysfs_write "del ${OCF_RESKEY_lun}" ${exports}/../mgmt || {
                            ocf_log err "Unable to unexport LUN ${OCF_RESKEY_lun} - ${exports}";
                            exit $OCF_ERR_GENERIC
                        }
                        ocf_log debug "Unexported LUN ${OCF_RESKEY_lun} - ${exports}"
                    fi
                done
            ;;
            stop)
                # Clear the acls on stop of the lun.
                ocf_log debug "Remove all exports for LUN ${OCF_RESKEY_lun}, target ${target}."
                for exports in ${exports_del[@]}; do
                    if [ -d "${exports}" ]; then
                        scst_sysfs_write "del ${OCF_RESKEY_lun}" ${exports}/../mgmt || {
                            ocf_log err "Unable to unexport LUN ${OCF_RESKEY_lun} - ${exports}";
                            exit $OCF_ERR_GENERIC
                        }
                    ocf_log debug "${OCF_RESOURCE_INSTANCE}: Unexported LUN ${OCF_RESKEY_lun} - ${exports}"
                    fi
                done
            ;;
        esac
        # remove empty (or only exporting lun 0) ini_groups
        for initiator in $(find ${FABRIC_BASE}/${target}/ini_groups/ -mindepth 1 -maxdepth 1 -type d) ; do
            if [ $(find ${initiator}/luns -mindepth 1 -maxdepth 1 -type d ! -name '0' | wc -l) -eq 0 ] ; then
                # Forcefully close all sessions.
                # When using iSCSI MPIO, several sessions per initiator can be available.
                for session in $(ls -1d ${FABRIC_BASE}/${target}/sessions/${initiator##*/} \
                                        ${FABRIC_BASE}/${target}/sessions/${initiator##*/}_* 2>/dev/null) ; do
                    scst_sysfs_write "1" "${session}/force_close" && \
                    ocf_log warn "Forcefully closed session from initiator ${initiator##*/}."
                done
                # Delete the ini_group
                scst_sysfs_write "del ${initiator##*/}" ${FABRIC_BASE}/${target}/ini_groups/mgmt || {
                     ocf_log err "Unable to delete empty initiator group ${initiator##*/} from target ${target}.";
                     exit $OCF_ERR_GENERIC
                }
                ocf_log debug "${OCF_RESOURCE_INSTANCE}: Deleted empty initiator group ${initiator##*/} from target ${target}."
           fi
        done
    done

    return $OCF_SUCCESS
}

SCSTLogicalUnit_start() {
    SCSTLogicalUnit_monitor
    rc=$?
    case $rc in
        $OCF_SUCCESS|$OCF_RUNNING_MASTER) return $rc ;;
    esac

    local all_params
    local dev_path
    local dev_group
    local index
    local initiator
    local ini_path
    local handler_path
    local param
    local target
    local tpg
    declare -a tpgs=( $(echo -n ${OCF_RESKEY_alua_tpg}) )

    handler_path="${SCST_BASE}/handlers/${OCF_RESKEY_device_handler}"
    dev_path="${handler_path}/${OCF_RESOURCE_INSTANCE}"

    # Set all additional parameters
    all_params=""
    for param in ${OCF_RESKEY_additional_parameters}; do
        all_params="${all_params}; ${param}"
    done
    ocf_log debug "${OCF_RESOURCE_INSTANCE}: Prepared specific parameter \"${all_params}\" for device handler ${OCF_RESKEY_device_handler}."

    # Check if handler is loaded
    if [ ! -e "${handler_path}" ]; then
        ocf_log err "Device handler ${OCF_RESKEY_device_handler} not loaded.";
        exit $OCF_ERR_GENERIC
    fi

    # Configure the backend device for the LU, name the
    # device like the cluster resource.
    if [ ! -e "${dev_path}" ]; then
        scst_sysfs_write "add_device ${OCF_RESOURCE_INSTANCE} filename=${OCF_RESKEY_path}${all_params}" ${handler_path}/mgmt || {
            ocf_log err "Unable to add device ${OCF_RESOURCE_INSTANCE} with path ${OCF_RESKEY_path} to ${OCF_RESKEY_device_handler} handler.";
            exit $OCF_ERR_GENERIC
        }
    fi
    ocf_log debug "${OCF_RESOURCE_INSTANCE}: Add device ${OCF_RESOURCE_INSTANCE} whith path ${OCF_RESKEY_path}."

    # Set the SCSI device id aka T10 device id
    if [ -n "${OCF_RESKEY_scsi_id}" ]; then
        scst_sysfs_write "${OCF_RESKEY_scsi_id}" ${dev_path}/t10_dev_id || {
            ocf_log err "Unable to set T10 device id ${OCF_RESKEY_scsi_id} for device ${OCF_RESOURCE_INSTANCE}.";
            exit $OCF_ERR_GENERIC
        }
    fi
    ocf_log debug "${OCF_RESOURCE_INSTANCE}: Set SCSI device id to ${OCF_RESKEY_scsi_id}."

    # Set the SCSI vendor specific id
    if [ -n "${OCF_RESKEY_vendor_specific_id}" ]; then
        scst_sysfs_write "${OCF_RESKEY_vendor_specific_id}" ${dev_path}/vend_specific_id || {
            ocf_log err "Unable to set vendor specific id ${OCF_RESKEY_vendor_specific_id} for device ${OCF_RESOURCE_INSTANCE}.";
            exit $OCF_ERR_GENERIC
        }
    fi
    ocf_log debug "${OCF_RESOURCE_INSTANCE}: Set SCSI vendor specific id to ${OCF_RESKEY_vendor_specific_id}."

    # Set the SCSI device serial number aka unit serial number
    if [ -n "${OCF_RESKEY_scsi_sn}" ]; then
        scst_sysfs_write "${OCF_RESKEY_scsi_sn}" ${dev_path}/usn || {
            ocf_log err "Unable to set usn ${OCF_RESKEY_scsi_sn} for device ${OCF_RESOURCE_INSTANCE}.";
            exit $OCF_ERR_GENERIC
        }
    fi
    ocf_log debug "${OCF_RESOURCE_INSTANCE}: Set SCSI serial number to ${OCF_RESKEY_scsi_sn}."

    # Set the SCSI product id
    if [ -n "${OCF_RESKEY_product_id}" ]; then
        scst_sysfs_write "${OCF_RESKEY_product_id}" ${dev_path}/prod_id || {
            ocf_log err "Unable to set product id ${OCF_RESKEY_product_id} for device ${OCF_RESOURCE_INSTANCE}.";
            exit $OCF_ERR_GENERIC
        }
    fi
    ocf_log debug "${OCF_RESOURCE_INSTANCE}: Set vendor id to ${OCF_RESKEY_vendor_id}."

    # Set the SCSI vendor id
    if [ -n "${OCF_RESKEY_vendor_id}" ]; then
        scst_sysfs_write "${OCF_RESKEY_vendor_id}" ${dev_path}/t10_vend_id || {
            ocf_log err "Unable to set usn ${OCF_RESKEY_vendor_id} for device ${OCF_RESOURCE_INSTANCE}.";
            exit $OCF_ERR_GENERIC
        }
    fi
    ocf_log debug "${OCF_RESOURCE_INSTANCE}: Set vendor id to ${OCF_RESKEY_vendor_id}."

    # Prepare for ALUA if configured
    if [ -n "${OCF_RESKEY_alua_tpg}" ]; then
        # For ALUA, create create a device group for this lun
        # and assign a device to the group
        dev_group="${SCST_BASE}/device_groups/${OCF_RESOURCE_INSTANCE}"
        if [ ! -d "${dev_group}" ]; then
            scst_sysfs_write "create ${OCF_RESOURCE_INSTANCE}" ${SCST_BASE}/device_groups/mgmt || {
                ocf_log err "Unable to create device_group for device ${OCF_RESOURCE_INSTANCE}.";
                exit $OCF_ERR_GENERIC
            }
        fi
        ocf_log debug "${OCF_RESOURCE_INSTANCE}: Created device_group ${OCF_RESOURCE_INSTANCE}."

        # Add the device to its device_group 
        if [ ! -e "${dev_group}/devices/${OCF_RESOURCE_INSTANCE}" ]; then
            scst_sysfs_write "add ${OCF_RESOURCE_INSTANCE}" ${dev_group}/devices/mgmt || {
                ocf_log err "Unable to add device ${OCF_RESOURCE_INSTANCE} to device_group ${OCF_RESOURCE_INSTANCE}.";
                exit $OCF_ERR_GENERIC
            }
        fi
        ocf_log debug "${OCF_RESOURCE_INSTANCE}: Added device ${OCF_RESOURCE_INSTANCE} to device_group ${OCF_RESOURCE_INSTANCE}."

        # The TPGs have to be named exactly as the node names (as Pacemaker uses it)
        # for "multi-node targets". The position decides about the TPG id.
        index=1
        for tpg in "${tpgs}"; do
            # Create the TPGs, one for each node
            if [ ! -d "${dev_group}/target_groups/${tpg}" ]; then
                scst_sysfs_write "create ${tpg}" ${dev_group}/target_groups/mgmt || {
                    ocf_log err "Unable to create target_group ${tpg} for device_group ${OCF_RESOURCE_INSTANCE}.";
                    exit $OCF_ERR_GENERIC
                }
            fi
            ocf_log debug "${OCF_RESOURCE_INSTANCE}: Created target_group ${tpg} for device_group ${OCF_RESOURCE_INSTANCE}."

            # Set the id for ALUA TPG
            if [ -d "${dev_group}/target_groups/${tpg}" ]; then
                scst_sysfs_write "${index}" ${dev_group}/target_groups/${tpg}/group_id || {
                    ocf_log err "Unable to set id ${index} for TPG ${tpg} for device_group ${OCF_RESOURCE_INSTANCE}.";
                    exit $OCF_ERR_GENERIC
                }
                ocf_log debug "${OCF_RESOURCE_INSTANCE}: Set id ${index} for TPG ${tpg} for device_group ${OCF_RESOURCE_INSTANCE}."
               
                # By default the TPG is not preferred and in standby mode
                scst_sysfs_write "0" ${dev_group}/target_groups/${tpg}/preferred || {
                    ocf_log err "Unable to set preferred to 0 - TPG ${tpg}, device_group ${OCF_RESOURCE_INSTANCE}.";
                }
                scst_sysfs_write "standby" ${dev_group}/target_groups/${tpg}/state || {
                    ocf_log err "Unable to set state to standby - TPG ${tpg}, device_group ${OCF_RESOURCE_INSTANCE}.";
                }
                ocf_log debug "${OCF_RESOURCE_INSTANCE}: TPG ${tpg} for device_group ${OCF_RESOURCE_INSTANCE} is standby/not preferred."

                # Add all targets to the target group,
                # use the target id also for the relative id
                for target in ${OCF_RESKEY_target_id}; do
                    if [ -d "${dev_group}/target_groups/${tpg}" ]; then
                        scst_sysfs_write "${index}" ${dev_group}/target_groups/${tpg}/group_id || {
                            ocf_log err "Unable to set id ${index} for TPG ${tpg} - device_group ${OCF_RESOURCE_INSTANCE}.";
                            exit $OCF_ERR_GENERIC
                        }
                        ocf_log debug "${OCF_RESOURCE_INSTANCE}: Set id ${index} for TPG ${tpg} - device_group ${OCF_RESOURCE_INSTANCE}."

                        if [ ! -L "${dev_group}/target_groups/${tpg}/${target}" ]; then
                            scst_sysfs_write "add ${target}" ${dev_group}/target_groups/${tpg}/mgmt || {
                                ocf_log err "Unable to add target ${target} to TPG ${tpg} for device_group ${OCF_RESOURCE_INSTANCE}.";
                                exit $OCF_ERR_GENERIC
                            }
                            ocf_log debug "${OCF_RESOURCE_INSTANCE}: Added target ${target} to TPG ${tpg} - device_group ${OCF_RESOURCE_INSTANCE}."
                        fi

                        if [ -d "${dev_group}/target_groups/${tpg}/${target}" ]; then
                            scst_sysfs_write "${index}" ${dev_group}/target_groups/${tpg}/${target}/rel_tgt_id || {
                                ocf_log err "Unable to set relative target id ${index} for target ${target} - device_group ${OCF_RESOURCE_INSTANCE}.";
                                exit $OCF_ERR_GENERIC
                            }
                            ocf_log debug "${OCF_RESOURCE_INSTANCE}: Set rel_tgt_id ${index} for target ${target} - TPG ${tpg}, device_group ${OCF_RESOURCE_INSTANCE}."
                        fi
                   fi 
                done
            fi
            index++
        done
    fi

    # export the LU to all allowed initiators
    SCSTLogicalUnit_acls

    ocf_is_ms && update_master_score

    return $OCF_SUCCESS
}

SCSTLogicalUnit_reload() {
    case $OCF_RESKEY_fabric in
	iscsi|qla2xxx)
            SCSTLogicalUnit_start
	    ;;
    esac

    return $OCF_SUCCESS
}

SCSTLogicalUnit_stop() {
    local ini_path
    local target
    local initiator

    SCSTLogicalUnit_monitor
    SCSTLogicalUnit_acls

    # Delete the device definition for LU
    if [ -e "${SCST_BASE}/devices/${OCF_RESOURCE_INSTANCE}" ]; then
        scst_sysfs_write "del_device ${OCF_RESOURCE_INSTANCE}" ${SCST_BASE}/handlers/${OCF_RESKEY_device_handler}/mgmt || {
            ocf_log err "Unable to delete device ${OCF_RESOURCE_INSTANCE} from ${OCF_RESKEY_device_handler} handler.";
            exit $OCF_ERR_GENERIC
        }
    fi
    ocf_log debug "${OCF_RESOURCE_INSTANCE}: Deleted device ${OCF_RESOURCE_INSTANCE} from ${OCF_RESKEY_device_handler} handler."

    # In case of a block device, flush any outstanding I/O to the device
    if [ -b $OCF_RESKEY_path ]; then
        ocf_log debug "${OCF_RESOURCE_INSTANCE}: Flush outstanding I/O to device ${OCF_RESKEY_path}."
        # This can really take some time, allow other LUNs
        # to take the lock
        [ -e "$LOCKFILE" ] && ocf_run rm -vf $LOCKFILE
        ocf_run blockdev -v --flushbufs $OCF_RESKEY_path
    fi

    remove_master_score

    return $OCF_SUCCESS
}

SCSTLogicalUnit_monitor() {
    local alua_state
    local lun_path
    local handler_path
    local dev_path
    local target
    local initiator
    local index
    local counter
    declare -a ids=( $(echo -n ${OCF_RESKEY_target_id}) )

    handler_path="${SCST_BASE}/handlers/${OCF_RESKEY_device_handler}"
    dev_path="${handler_path}/${OCF_RESOURCE_INSTANCE}"
    alua_state="standby"
    index=${#ids[@]}

    # If our backing device (or file) doesn't even exist, we're not running
    [ -e ${OCF_RESKEY_path} ] || {
        ocf_log warn "Backing device (or file) ${OCF_RESKEY_path} not available - Assuming LU ${OCF_RESOURCE_INSTANCE} is not up.";
        return $OCF_NOT_RUNNING
    }

    # If our device handler is not available we're not running
    [ -e ${handler_path} ] || {
        ocf_log warn "Device handler ${OCF_RESKEY_device_handler} not loaded - Assuming LU ${OCF_RESOURCE_INSTANCE} is not up.";
        return $OCF_NOT_RUNNING
    }

    # If our device is not configured we're not running
    [ -e ${dev_path} ] || {
        ocf_log debug "Device ${OCF_RESOURCE_INSTANCE} of type ${OCF_RESKEY_device_handler} not available - Assuming LU ${OCF_RESOURCE_INSTANCE} is not up.";
        return $OCF_NOT_RUNNING
    }

    # Check all targets
    for target in ${OCF_RESKEY_target_id}; do
        # Fill an array with all exports of this LU
        declare -a lun_path=( $(ls -1d ${FABRIC_BASE}/${target}/ini_groups/*/luns/${OCF_RESKEY_lun}/device 2>/dev/null | tr '\n' ' ') )
        counter=0
        # Check if they all export the same backend device
        for initiator in "${lun_path[@]}"; do
            [ -e "$initiator" ]  && [ `scst_sysfs_read "${initiator}/filename"` = "${OCF_RESKEY_path}" ] && (( counter++ ))
        done
        [ $counter -eq ${#lun_path[@]} ] && (( index-- ))
    done

    if [[ $index -eq 0 ]]; then
        # The lun seems to be availaddble, also verify/fix its acls,
        # but not on stop
        [ "$__OCF_ACTION" = "stop" ] || SCSTLogicalUnit_acls

        # Now check the ALUA state
        if [ -n "${OCF_RESKEY_alua_tpg}" ]; then
            alua_state="$(scst_sysfs_read ${SCST_BASE}/device_groups/${OCF_RESOURCE_INSTANCE}/target_groups/${HOSTNAME}/state)"
            case $alua_state in
                active)
                    update_master_score
                    return $OCF_RUNNING_MASTER
                    ;;
                standby)
                    update_master_score
                    return $OCF_SUCCESS
                    ;;
                *)
                    return $OCF_FAILED_MASTER
                    ;;
           esac
        fi
        return $OCF_SUCCESS
    fi
    # catch only "half"-configured LUNs, manual intervention
    # may be needed ... but only on start or monitor
    if [[ $index -ne ${#ids[@]} ]]; then
        case $__OCF_ACTION in
            monitor|start)
                ocf_log error "${OCF_RESOURCE_INSTANCE}/LUN ${OCF_RESKEY_lun} with path/file ${OCF_RESKEY_path} is not associated correctly to all its targets!"
                remove_master_score
                exit $OCF_ERR_GENERIC
                ;;
            stop)
                remove_master_score
                return $OCF_SUCCESS
                ;;
        esac
    fi

    return $OCF_NOT_RUNNING
}

SCSTLogicalUnit_promote() {
    SCSTLogicalUnit_monitor
    rc=$?

    case $rc in
    $OCF_SUCCESS)
        update_alua_access_state $HOSTNAME active || {
            ocf_log error "Unable to set ALUA access state for lun_${OCF_RESKEY_lun}/${OCF_RESOURCE_INSTANCE} to active/optimized!";
            exit $OCF_ERR_GENERIC
        }
        ocf_log debug "${OCF_RESOURCE_INSTANCE}: ALUA - promoting was successfull, TPG $HOSTNAME is now optimized"
        ;;
    $OCF_NOT_RUNNING)
        ocf_log error "ALUA: Trying to promote resource ${OCF_RESOURCE_INSTANCE} that was not started"
        break
        ;;
    $OCF_RUNNING_MASTER)
        ocf_log debug "${OCF_RESOURCE_INSTANCE}: ALUA - Promotion was successful"
        rc=$OCF_SUCCESS
        break
        ;;
    esac
    sleep 3

    return $rc
}

SCSTLogicalUnit_demote() {
    SCSTLogicalUnit_monitor
    rc=$?

    case $rc in
    $OCF_RUNNING_MASTER)
        update_alua_access_state $HOSTNAME standby || {
            ocf_log error "Unable to set ALUA access state for lun_${OCF_RESKEY_lun}/${OCF_RESOURCE_INSTANCE} to standby!";
            exit $OCF_ERR_GENERIC
        }
        ocf_log debug "${OCF_RESOURCE_INSTANCE}: ALUA - demote was successfull, TPG $HOSTNAME is now standby"
        ;;
    $OCF_NOT_RUNNING)
        ocf_log error "ALUA - Trying to demote a resource that was not started"
        break
        ;;
    $OCF_SUCCESS)
        ocf_log debug "${OCF_RESOURCE_INSTANCE}: ALUA - Demotion was successful"
        rc=$OCF_SUCCESS
        break
        ;;
        esac
    sleep 3

    return $rc
}

SCSTLogicalUnit_notify() {
    local n_type=$OCF_RESKEY_CRM_meta_notify_type
    local n_op=$OCF_RESKEY_CRM_meta_notify_operation
    local demoteit=$OCF_RESKEY_CRM_meta_notify_demote_uname
    local promoteit=$OCF_RESKEY_CRM_meta_notify_promote_uname
    local stopit=$OCF_RESKEY_CRM_meta_notify_stop_uname
    local startit=$OCF_RESKEY_CRM_meta_notify_start_uname
    local master=$OCF_RESKEY_CRM_meta_notify_master_uname
    local slave=$OCF_RESKEY_CRM_meta_notify_slave_uname
    local node
    local instance

    case $n_type/$n_op in
        post/start)
            # Switch all new slave instances TPG to standby
            for node in $startit; do
                # Do we have any master(s) at all and did the start happened locally?
                if [ "$node" = "$HOSTNAME" ]; then
                    # We are slave: be sure the master(s) TPG is also
                    # set to active (without luns) on this node.
                    # We rely on default standby state on creation.
                    for instance in $master; do
                         update_alua_access_state $instance active
                    done
                fi
            done
            ;;
        post/promote)
            for node in $promoteit; do
                # Switch all new master instances TPG to active.
                update_alua_access_state $node active
            done
            ;;
        post/demote)
            for node in $demoteit; do
                # Switch all new slave instances TPG to standby
                update_alua_access_state $node standby
            done
            ;;
        post/stop)
            # So some node(s) has/have inactive resources, is it me?
            for node in $stopit; do
                if [ "$node" != "$HOSTNAME" ]; then
                    # Another node stopped the resource,
                    # its TPGs are definitely standby.
                    update_alua_access_state $node standby
                fi
            done
            ;;
    esac

    return $OCF_SUCCESS
}

SCSTLogicalUnit_validate() {
    # Do we have all required variables?
    for var in target_id lun path; do
	param="OCF_RESKEY_${var}"
	if [ -z "${!param}" ]; then
	    ocf_log error "Missing resource parameter \"$var\"!"
	    exit $OCF_ERR_CONFIGURED
	fi
    done

    # Do we have a valid LUN?
    # We always use dummy LUN 0
    [ $OCF_RESKEY_lun -ge 1 ]
    case $? in
        0)
            # OK
            ;;
        1)
            ocf_log err "Invalid LUN $OCF_RESKEY_lun (must be greater than 0)."
            exit $OCF_ERR_CONFIGURED
            ;;
        *)
            ocf_log err "Invalid LUN $OCF_RESKEY_lun (must be an integer)."
            exit $OCF_ERR_CONFIGURED
            ;;
    esac

    # Is the configured fabric supported?
    case "$OCF_RESKEY_fabric" in
	"iscsi")
            :
	    ;;
	*)
	    ocf_log error "Unsupported SCST target fabric \"$OCF_RESKEY_fabric\"!"
	    exit $OCF_ERR_CONFIGURED
	    ;;
    esac

    # Do we have any configuration parameters that the current
    # fabric does not support?
    local unsupported_params
    local var
    local envar
    case $OCF_RESKEY_fabric in
	iscsi)
	    unsupported_params=""
	    ;;
    esac
    for var in ${unsupported_params}; do
	envar=OCF_RESKEY_${var}
	defvar=OCF_RESKEY_${var}_default
	if [ -n "${!envar}" ]; then
	    if  [[ "${!envar}" != "${!defvar}" ]];then 
	        case "$__OCF_ACTION" in
                    start|validate-all)
                      ocf_log warn "Configuration parameter \"${var}\"" \
                       "is not supported by SCST's ${OCF_RESKEY_fabric} fabric" \
                       "and will be ignored." ;;
	        esac
	    fi
	fi
    done

    if ! ocf_is_probe; then
        # Do we have all required binaries?
	case $OCF_RESKEY_fabric in
	    iscsi)
                check_binary find
                ;;
	esac

        # Is the required kernel functionality available?
	case $OCF_RESKEY_fabric in
	    iscsi)
		[ -d "${FABRIC_BASE}" ] || {
		    ocf_log err "${FABRIC_BASE} does not exist or is not a directory -- check if required modules are loaded.";
		    exit $OCF_ERR_INSTALLED
                }
		;;
	esac

	[ -d "${SCST_BASE}/handlers/${OCF_RESKEY_device_handler}" ] || {
	    ocf_log err "${OCF_RESKEY_device_handler} handler does not exist or is not a directory -- check if required modules are loaded.";
	    exit $OCF_ERR_INSTALLED
        }
    fi

    # We need the nodename several times.
    HOSTNAME=$(crm_node -n)

    return $OCF_SUCCESS
}


case $1 in
  meta-data)
	meta_data
	exit $OCF_SUCCESS
	;;
  usage|help)
	SCSTLogicalUnit_usage
	exit $OCF_SUCCESS
	;;
esac

if $USE_DEBUG_LOG ; then
    exec 2>&9
    set -x
fi

# Everything except usage and meta-data must pass the validate test
SCSTLogicalUnit_validate

case $__OCF_ACTION in
    start)
        SCSTLogicalUnit_start
        ;;
    stop)
        SCSTLogicalUnit_stop
        ;;
    monitor|status)
        SCSTLogicalUnit_monitor
        ;;
    reload)
        ocf_log info "Reloading..."
        SCSTLogicalUnit_reload
        ;;
    promote)
        SCSTLogicalUnit_promote
        ;;
    demote)
        SCSTLogicalUnit_demote
        ;;
    validate-all)
        ;;
    *)
        SCSTLogicalUnit_usage
        exit $OCF_ERR_UNIMPLEMENTED
	;;
esac
rc=$?
ocf_log debug "${OCF_RESOURCE_INSTANCE} $__OCF_ACTION : $rc"
exit $rc
