#!/bin/sh
#
# EnhanceIO
#
# Description:  Resource Agent for highly available EnhanceIO caches.
#               Requires installed EnhanceIO kernel module and utilities.
#
# Author:       Andreas Kurz
#
# Support:      linux-ha@lists.linux-ha.org
# License:      GNU General Public License (GPL)
#
# (c) 2015-2017 Andreas Kurz <andreas.kurz AT gmail DOT com>
# (c) 2013      hastexo Professional Services GmbH
#
# This resource agent is derived from the flashcache resource
# agent, which itself is made available to the public under the
# following copyright:
#
# (c) 2011      Florian Haas
#
# See usage() function below for more details ...
#
# OCF instance parameters:
#   OCF_RESKEY_src_device
#   OCF_RESKEY_ssd_device
#   OCF_RESKEY_cache_name
#   OCF_RESKEY_policy
#   OCF_RESKEY_cache_mode
#   OCF_RESKEY_block_size
#   OCF_RESKEY_gpt_partition_name
#   OCF_RESKEY_persistent_cache
#######################################################################
# Initialization:

: ${OCF_FUNCTIONS_DIR=${OCF_ROOT}/lib/heartbeat}
. ${OCF_FUNCTIONS_DIR}/ocf-shellfuncs

# Defaults
OCF_RESKEY_policy_default="fifo"
OCF_RESKEY_cache_mode_default="wt"
OCF_RESKEY_block_size_default="4096"
OCF_RESKEY_gpt_partition_name_default="eio_cache"
OCF_RESKEY_persistent_cache_default="false"

: ${OCF_RESKEY_policy=${OCF_RESKEY_policy_default}}
: ${OCF_RESKEY_cache_mode=${OCF_RESKEY_cache_mode_default}}
: ${OCF_RESKEY_block_size=${OCF_RESKEY_block_size_default}}
: ${OCF_RESKEY_gpt_partition_name=${OCF_RESKEY_gpt_partition_name_default}}
: ${OCF_RESKEY_persistent_cache=${OCF_RESKEY_persistent_cache_default}}

UDEVFILE="/etc/udev/rules.d/94-enhanceio-${OCF_RESKEY_cache_name}.rule"

erase_metadata() {
    local mdhave
    local mdwant
    mdhave="$(dd if=${OCF_RESKEY_ssd_device} bs=128K count=1 iflag=direct 2>/dev/null | \
		strings | tr '\n' ' ')"
    mdwant="${OCF_RESKEY_ssd_device} ${OCF_RESKEY_src_device} ${OCF_RESKEY_cache_name} "

    # Only erase own metadata - correct src_device/ssd_device/resource name
    # must be found in the first 128kB of the cache device.
    if [ "${mdhave}" = "${mdwant}" ]; then
	ocf_log info "Deleting EIO metadata on device ${OCF_RESKEY_ssd_device}."
	ocf_run -q dd if=/dev/zero bs=128K count=1 oflag=direct of=${OCF_RESKEY_ssd_device}
    else
	ocf_log info "Not erasing EIO meta data. Searched for \"${mdwant}\" but found: \"${mdhave}\""
    fi
    # Just to be sure ...
    rm -f "${UDEVFILE}"

    # Don't fail on meta data cleanup
    return $OCF_SUCCESS
}

enhanceio_usage() {
  echo "usage: $0 {start|stop|status|monitor|meta-data|validate-all}"
}

enhanceio_meta_data() {
    cat <<EOF
<?xml version="1.0"?>
<!DOCTYPE resource-agent SYSTEM "ra-api-1.dtd">
<resource-agent name="EnhanceIO" version="0.4">
  <version>0.4</version>
  <longdesc lang="en">
This resource agent manages an EnhanceIO cache device, loading any existing
cache from the flash device on startup and flushing the cache to the
disk on graceful shutdown.
  </longdesc>
  <shortdesc lang="en">Manages an EnhanceIO cache</shortdesc>
  <parameters>
    <parameter name="src_device" unique="1" required="1">
      <longdesc lang="en">
      The name of the source device. This is typically a
      comparatively high-latency but high-capacity block device,
      such as a rotational disk.
      </longdesc>
      <shortdesc lang="en">Source device name</shortdesc>
      <content type="string"/>
    </parameter>
    <parameter name="ssd_device" unique="1" required="1">
      <longdesc lang="en">
      The SSD cache device to be used by EnhanceIO.
      </longdesc>
      <shortdesc lang="en">SSD device</shortdesc>
      <content type="string"/>
    </parameter>
    <parameter name="cache_name" unique="1" required="1">
      <longdesc lang="en">
      The cache device to be created by EnhanceIO.
      </longdesc>
      <shortdesc lang="en">Cache device name</shortdesc>
      <content type="string"/>
    </parameter>
    <parameter name="policy" unique="0" required="0">
      <longdesc lang="en">
      Cache block replacement policy. Policies are:
      lru, fifo(default), rand(random).
      </longdesc>
      <shortdesc lang="en">Cache block replacement policy</shortdesc>
      <content type="string" default="${OCF_RESKEY_policy_default}"/>
    </parameter>
    <parameter name="cache_mode" unique="0" required="0">
      <longdesc lang="en">
      Specifies  the  caching  mode. Supported caching modes are:
      ro(Read-Only), wt(default: Write-Through), wb(Write-Back).
      </longdesc>
      <shortdesc lang="en">The caching mode</shortdesc>
      <content type="string" default="${OCF_RESKEY_cache_mode_default}"/>
    </parameter>
    <parameter name="block_size" unique="0" required="0">
      <longdesc lang="en">
      Specifies the block size of each single cache entry.
      Block sizes are: 2048, 4096(default), 8192.
      </longdesc>
      <shortdesc lang="en">Cache entry block size</shortdesc>
      <content type="integer" default="${OCF_RESKEY_block_size_default}"/>
    </parameter>
    <parameter name="gpt_partition_name" unique="0" required="0">
      <longdesc lang="en">
      The GPT partition name that is used on the cache device's
      SSD partition. A name must be set to safely identify
      the partition for disabling cache persistence. This name
      is NOT set by this resource agent.
      </longdesc>
      <shortdesc lang="en">SSD GPT partition name</shortdesc>
      <content type="string" default="${OCF_RESKEY_gpt_partition_name_default}"/>
    </parameter>
    <parameter name="persistent_cache" unique="0" required="0">
      <longdesc lang="en">
      In a HA environment it normally makes no sense to
      have EIO cache persistence over reboots as there
      is another node taking over the cache. So the cached
      data is very likely outdated and stale after a reboot.
      So by default the persistence is disabled.
      </longdesc>
      <shortdesc lang="en">Enable cache persistence</shortdesc>
      <content type="boolean" default="${OCF_RESKEY_persistent_cache}"/>
    </parameter>
  </parameters>
  <actions>
    <action name="start"        timeout="60" />
    <action name="stop"         timeout="180" />
    <action name="reload"       timeout="60" />
    <action name="monitor"      timeout="20" />
    <action name="meta-data"    timeout="5" />
    <action name="validate-all" timeout="20" />
  </actions>
</resource-agent>
EOF
}

enhanceio_start() {
    local params

    # if resource is already running, bail out early
    if enhanceio_monitor; then
        ocf_log info "Resource is already running"
        return $OCF_SUCCESS
    fi

    # If the file exists here, but enhanceio_monitor has determined
    # the resource isn't already running, then the file probably is
    # owned by something else. Bail out to avoid breaking things.
    if [ -e /proc/enhanceio/${OCF_RESKEY_cache_name} ]; then
	ocf_log err "Existing file /proc/enhanceio/${OCF_RESKEY_name} would be overwritten by ${OCF_RESOURCE_INSTANCE}. Bailing out."
	exit $OCF_ERR_INSTALLED
    fi

    # Cleanup any old metadata before starting
    if ! ocf_is_true ${OCF_RESKEY_persistent_cache}; then
	erase_metadata
    fi

    if [ ! -e /proc/enhanceio/version ]; then
	ocf_log debug "Enhanceio support not loaded, loading module"
	ocf_run modprobe -v enhanceio || exit $OCF_ERR_INSTALLED
    fi

    ocf_log debug "Enhanceio module information obtained from kernel: $(cat /proc/enhanceio/version)"

    # Reload is possible on "policy" or "cache_mode"
    # changes.
    case $__OCF_ACTION in
        start)
            params="create -d ${OCF_RESKEY_src_device} -s ${OCF_RESKEY_ssd_device} -b ${OCF_RESKEY_block_size} -p ${OCF_RESKEY_policy} -m ${OCF_RESKEY_cache_mode}"
            ;;
        reload)
            params="edit -p ${OCF_RESKEY_policy} -m ${OCF_RESKEY_cache_mode}"
            ;;
    esac

    # actually start up the resource here (make sure to immediately
    # exit with an $OCF_ERR_ error code if anything goes seriously
    # wrong)
    ocf_run eio_cli $params -c ${OCF_RESKEY_cache_name} || exit $OCF_ERR_GENERIC

    # After the resource nhas been started, check whether it started up
    # correctly. If the resource starts asynchronously, the agent may
    # spin on the monitor function here -- if the resource does not
    # start up within the defined timeout, the cluster manager will
    # consider the start action failed
    while ! enhanceio_monitor; do
        ocf_log debug "Resource has not started yet, waiting"
        sleep 1
    done

    # Normally we want the udev rule file being deleted - no
    # cache persistence. Delete the file already after starting
    # in case the stop is not successful.
    if ! ocf_is_true ${OCF_RESKEY_persistent_cache}; then
	rm -f "${UDEVFILE}"
    fi

    return $OCF_SUCCESS
}

enhanceio_stop() {
    local rc
    local msg
    local ignore

    enhanceio_monitor
    rc=$?
    case "$rc" in
        "$OCF_SUCCESS")
            # Currently running. Normal, expected behavior.
            ocf_log debug "Resource is currently running"
            ;;
        "$OCF_NOT_RUNNING")
            # Currently not running. Nothing to do.
            ocf_log info "Resource is already stopped"
            return $OCF_SUCCESS
            ;;
    esac

    # actually shut down the resource here (make sure to immediately
    # exit with an $OCF_ERR_ error code if anything goes seriously
    # wrong)
    # 1. switch into ro mode, no further changes on the cache
    #    are possible
    ocf_log debug "Switching cache into read only mode"
    ocf_run eio_cli edit -m ro -c ${OCF_RESKEY_cache_name}
    # 2. wait for data in cache to be written to slower disk
    ocf_log info "Waiting for cached data to be flushed to disk"
    while true; do
        grep -E -q "^nr_dirty[[:space:]]+0\$" \
        /proc/enhanceio/${OCF_RESKEY_cache_name}/stats && break
        ocf_log debug "Still waiting for cached data to drain: $(grep nr_dirty /proc/enhanceio/${OCF_RESKEY_cache_name}/stats)"
        sleep 1
    done
    ocf_log info "Deleting the cache device"
    # 3. data is now consistent also for wb mode - delete the cache device
    ocf_run eio_cli delete -c ${OCF_RESKEY_cache_name}
    rc=$?
    # For unsupported devices eio_cli fails to create an
    # udev-rule file on start. On stop it exits with
    # rc=3 if it is unable to delete this missing file
    # but in fact it's stopped. Also other cases in src
    # for stop (delete) errors don't look critical.
    if [ "$rc" -ne 0 -a "$rc" -ne 3 ]; then
        exit $OCF_ERR_GENERIC
    fi

    # After the resource has been stopped, check whether it shut down
    # correctly. If the resource stops asynchronously, the agent may
    # spin on the monitor function here -- if the resource does not
    # shut down within the defined timeout, the cluster manager will
    # consider the stop action failed
    while enhanceio_monitor; do
        ocf_log debug "Resource has not stopped yet, waiting"
        sleep 1
    done

    # Cleanup any meta-data before next start or for device reuse
    if ! ocf_is_true ${OCF_RESKEY_persistent_cache}; then
	erase_metadata
	rm -f "${UDEVFILE}"
    fi

    return $OCF_SUCCESS

}

enhanceio_monitor() {
    local rc
    local dev
    local key
    local val
    local nr

    # No devices, assume the enhanceio cache is not running
    # - if no configuration is present. Give out some warnings,
    # let the agent cleanup.
    for dev in ${OCF_RESKEY_src_device} ${OCF_RESKEY_ssd_device}; do
        if [ ! -b ${dev} ]; then
            ocf_log warn "${dev} does not exist or is not a block device!"
            if [ -e ${config} ]; then
                ocf_log warn "${dev} missing or not a block device but there is an EnhanceIO config - try to cleanup!"
            fi
        fi
    done

    # First, see if the cache is configured 
    config=/proc/enhanceio/${OCF_RESKEY_cache_name}/config
    if [ -e ${config} ]; then
        # OK, let's check if it has the correct devices and block size configured  
        # In /proc: "src_device" maps to "src_name"
        #          "ssd_device" maps to "ssd_name"
	for key in src_name ssd_name block_size; do
            case $key in
                src_name)   val="$OCF_RESKEY_src_device";;
                ssd_name)   val="$OCF_RESKEY_ssd_device";;
                block_size) val="$OCF_RESKEY_block_size";;
            esac
	    grep -E -q "^${key}[[:space:]]+${val}\$" $config
            if [ $? -ne 0 ]; then
                ocf_log err "Existing config ${config} would be overwritten by ${OCF_RESOURCE_INSTANCE}. Bailing out."
                exit $OCF_ERR_INSTALLED
	    fi
        done
        # Let's also check policy and cache_mode
        # from the source:
        # CACHE_MODE_WB 1
        # CACHE_MODE_RO 2
        # CACHE_MODE_WT 3
        # CACHE_REPL_FIFO 1
        # CACHE_REPL_LRU 2
        # CACHE_REPL_RANDOM 3
        # In /proc: "policy" maps to "eviction"
        #           "cache_mode" maps to "mode"
        for key in eviction mode; do
            case $key in
                eviction) val="$OCF_RESKEY_policy";;
                mode)     val="$OCF_RESKEY_cache_mode";;
            esac
            case $val in
                wb|fifo) nr="1" ;;
                ro|lru)  nr="2" ;;
                wt|rand) nr="3" ;;
            esac
            grep -E -q "^${key}[[:space:]]+${nr}$" $config
            if [ $? -ne 0 ]; then
                ocf_log warn "Existing config ${config} detected but with different settings: ${key}!=${val}"
	    fi
        done
        # Great!
        return $OCF_RUNNING
    fi

    return $OCF_NOT_RUNNING
}

enhanceio_validate_all() {
    local bin

    # Check required parameters
    if [ -z "${OCF_RESKEY_src_device}" ]; then
	ocf_log err "Required parameter \"src_device\" not configured!"
	exit $OCF_ERR_CONFIGURED
    fi
    if [ -z "${OCF_RESKEY_ssd_device}" ]; then
	ocf_log err "Required parameter \"ssd_device\" not configured!"
	exit $OCF_ERR_CONFIGURED
    fi
    if [ -z "${OCF_RESKEY_cache_name}" ]; then
	ocf_log err "Required parameter \"cache_name\" not configured!"
	exit $OCF_ERR_CONFIGURED
    fi

    # Check valid options
    case ${OCF_RESKEY_cache_mode} in
        wt|ro|wb) ;;
        *) exit $OCF_ERR_CONFIGURED;;
    esac
    case ${OCF_RESKEY_policy} in
        fifo|lru|rand) ;;
        *) exit $OCF_ERR_CONFIGURED;;
    esac
    case ${OCF_RESKEY_block_size} in
        2048|4096|8192) ;;
        *) exit $OCF_ERR_CONFIGURED;;
    esac

    # Test for required binaries
    for bin in eio_cli grep blkid dd tr strings; do
	check_binary $bin
    done

    # Don't validate devices on stop. At least try to
    # stop any remains.
    if ! ocf_is_probe && [ "$__OCF_ACTION" != "stop" ]; then
	for dev in ${OCF_RESKEY_src_device} ${OCF_RESKEY_ssd_device}; do
	    if [ ! -b ${dev} ]; then
		ocf_exit_reason "${dev} does not exist or is not a block device!"
		exit $OCF_ERR_INSTALLED
	    fi
	done
    fi

    # Test the ssd_device device for any filesystems/raids/other
    # usages that are detected by "blkid"
    if blkid -o udev -p ${OCF_RESKEY_ssd_device} | grep -qE '^ID_FS_'; then
	ocf_log error "The device \"${OCF_RESKEY_ssd_device}\" seems to be already in not-EIO-use."
	ocf_exit_reason "Device \"${OCF_RESKEY_ssd_device}\" in use - but not by EIO"
	exit $OCF_ERR_CONFIGURED
    fi

    # Is there the correct GPT partition name on the ssd_device?
    if ! blkid -o udev -p ${OCF_RESKEY_ssd_device} | \
	grep -qE "ID_PART_ENTRY_NAME=${OCF_RESKEY_gpt_partition_name}\$"; then
	ocf_log error "GPT partition name \"${OCF_RESKEY_gpt_partition_name}\" expected on device \"${OCF_RESKEY_ssd_device}\""
	ocf_exit_reason "Wrong GPT partition name on \"${OCF_RESKEY_ssd_device}\""
	exit $OCF_ERR_CONFIGURED
    fi

    return $OCF_SUCCESS
}

# Make sure meta-data and usage always succeed
case $__OCF_ACTION in
meta-data)      enhanceio_meta_data
                exit $OCF_SUCCESS
                ;;
usage|help)     enhanceio_usage
                exit $OCF_SUCCESS
                ;;
esac

# Anything other than meta-data and usage must pass validation
enhanceio_validate_all || exit $?

# Translate each action into the appropriate function call
case $__OCF_ACTION in
start)          enhanceio_start;;
stop)           enhanceio_stop;;
status|monitor) enhanceio_monitor;;
reload)         ocf_log info "Reloading..."
                enhanceio_start
                ;;
validate-all)   ;;
*)              enhanceio_usage
                exit $OCF_ERR_UNIMPLEMENTED
                ;;
esac
rc=$?

ocf_log debug "${OCF_RESOURCE_INSTANCE} $__OCF_ACTION returned $rc"
exit $rc

#
# vim:tabstop=4:shiftwidth=4:textwidth=0:wrapmargin=0:et:
