#!/bin/sh
#
# rbd-nbd
#
# Description: OCF Resource Agent for mapping and unmapping
#              RBD (RADOS Block Device) images to
#              NBD (Network Block Device) devices
#
# Author:      Andreas Kurz
#
# License:     GNU General Public License (GPL)
#
# (c) 2018 Andreas Kurz <andreas.kurz AT gmail DOT com>
###

# Initialization:
: ${OCF_FUNCTIONS_DIR=${OCF_ROOT}/lib/heartbeat}
. ${OCF_FUNCTIONS_DIR}/ocf-shellfuncs
###

# Defaults
OCF_RESKEY_cephconf_default="/etc/ceph/ceph.conf"
OCF_RESKEY_exclusive_default="false"
OCF_RESKEY_nbds_max_default="256"
OCF_RESKEY_pool_default="rbd"
OCF_RESKEY_ro_default="false"

: ${OCF_RESKEY_cephconf=${OCF_RESKEY_cephconf_default}}
: ${OCF_RESKEY_exclusive=${OCF_RESKEY_exclusive_default}}
: ${OCF_RESKEY_nbds_max=${OCF_RESKEY_nbds_max_default}}
: ${OCF_RESKEY_pool=${OCF_RESKEY_pool_default}}
: ${OCF_RESKEY_ro=${OCF_RESKEY_ro_default}}
###

rbdnbd_meta_data() {
  cat <<EOF
<?xml version="1.0"?>
<!DOCTYPE resource-agent SYSTEM "ra-api-1.dtd">
<resource-agent name="rbd-nbd">
<version>0.1</version>

<longdesc lang="en">
This resource agents maps and unmaps RADOS Block Device (RBD) images
to Network Block Device (NBD) devices. 
</longdesc>
<shortdesc lang="en">Maps and unmaps RBDs to NBDs</shortdesc>

<parameters>
<parameter name="name" unique="0" required="1">
<longdesc lang="en">
Name of the RBD image.
</longdesc>
<shortdesc lang="en">RBD image name</shortdesc>
<content type="string"/>
</parameter>

<parameter name="pool" unique="0" required="0">
<longdesc lang="en">
Name of the RADOS pool where the RBD image has been created.
</longdesc>
<shortdesc lang="en">RADOS pool name</shortdesc>
<content type="string" default="${OCF_RESKEY_pool_default}"/>
</parameter>

<parameter name="snap" unique="0" required="0">
<longdesc lang="en">
Name of the RBD image snapshot to map.
</longdesc>
<shortdesc lang="en">Snapshot name</shortdesc>
<content type="string"/>
</parameter>

<parameter name="cephconf" unique="0" required="0">
<longdesc lang="en">
Location of the Ceph configuration file.
</longdesc>
<shortdesc lang="en">Ceph configuration file</shortdesc>
<content type="string" default="${OCF_RESKEY_cephconf_default}"/>
</parameter>

<parameter name="user" unique="0" required="0">
<longdesc lang="en">
Ceph client id (without 'client.' prefix) to use when mapping
the image. Required if Ceph authentication is enabled and
not the default id "admin" is used.
</longdesc>
<shortdesc lang="en">Ceph client id</shortdesc>
<content type="string"/>
</parameter>

<parameter name="ro" unique="0" required="0">
<longdesc lang="en">
Map the RBD image read only.
</longdesc>
<shortdesc lang="en">Read only mapping</shortdesc>
<content type="boolean" default="${OCF_RESKEY_ro_default}"/>
</parameter>

<parameter name="exclusive" unique="0" required="0">
<longdesc lang="en">
Forbid writes to the RBD image by other clients than NBD.
</longdesc>
<shortdesc lang="en">Allow writes only via NBD</shortdesc>
<content type="boolean" default="${OCF_RESKEY_exclusive_default}"/>
</parameter>

<parameter name="nbds_max" unique="0" required="0">
<longdesc lang="en">
Override the nbds_max parameter of NBD kernel module when modprobe.
</longdesc>
<shortdesc lang="en">Maximum number of NBD devices</shortdesc>
<content type="integer" default="${OCF_RESKEY_nbds_max_default}"/>
</parameter>
</parameters>

<actions>
<action name="start"        timeout="60" />
<action name="stop"         timeout="180" />
<action name="monitor"      timeout="20"
                            interval="10" depth="0" />
<action name="meta-data"    timeout="5" />
<action name="validate-all" timeout="20" />
</actions>

</resource-agent>
EOF
}

rbdnbd_usage() {
  cat <<EOF
usage: $0 {start|stop|status|monitor|validate-all|meta-data}

Expects to have a fully populated OCF RA-compliant environment set.
EOF
}

get_nbd_info() {
  local pattern

  # Example output from "rbd-nbd list-mapped":
  # pid     pool image snap device
  # 1217604 rbd  test  -    /dev/nbd0

  # Substitute "-" for the snapshot name if needed
  pattern="\([0-9]\+\)[ \t]\+${OCF_RESKEY_pool}[ \t]\+${OCF_RESKEY_name}[ \t]\+${OCF_RESKEY_snap:--}[ \t]\+\(/dev/nbd[0-9]\+\)[ \t]*$"

  # Get either the nbd-server pid or the device name
  case $1 in
    pid)
      rbd-nbd list-mapped 2>/dev/null | tail -n +2 | sed -n -e "s,$pattern,\1,p"
      ;;
    dev)
      rbd-nbd list-mapped 2>/dev/null | tail -n +2 | sed -n -e "s,$pattern,\2,p"
      ;;
  esac
}

rbdnbd_monitor() {
  local rc
  local nbd_dev

  if ! [ -d /sys/module/nbd ]; then
    ocf_log debug "nbd module is not loaded"
    return $OCF_NOT_RUNNING
  fi

  nbd_dev=$(get_nbd_info dev)

  if [ -z "$nbd_dev" ]; then
    ocf_log debug "RBD image $OCF_reskey_name is unmapped"
    rc=$OCF_NOT_RUNNING
  elif [ -b "$nbd_dev" ]; then
    ocf_log debug "RBD image $OCF_reskey_name is mapped to $nbd_dev"
    rc=$OCF_SUCCESS
  else
    # Device is listed, but it is not a block device
    ocf_log err "$nbd_dev is not a block device!"
    rc=$OCF_ERR_GENERIC
  fi

  return $rc
}

rbdnbd_start() {
  local rbdnbd_opts
  local rbd_name

  # if resource is already running, bail out early
  if rbdnbd_monitor; then
    ocf_log info "Resource is already running"
    return $OCF_SUCCESS
  fi

  # combine the map options
  rbdnbd_opts="--conf ${OCF_RESKEY_cephconf} --nbds_max ${OCF_RESKEY_nbds_max}"
  if [ -n "${OCF_RESKEY_user}" ]; then
    rbdnbd_opts="$rbdnbd_opts --id ${OCF_RESKEY_user}"
  fi
  if ocf_is_true "${OCF_RESKEY_ro}"; then
    rbdnbd_opts="$rbdnbd_opts --read-only"
  fi
  if ocf_is_true "${OCF_RESKEY_exclusive}"; then
    rbdnbd_opts="$rbdnbd_opts --exclusive"
  fi

  # prepare the image/snapshot name
  rbd_name="${OCF_RESKEY_pool}/${OCF_RESKEY_name}"
  if [ -n "${OCF_RESKEY_snap}" ]; then
    rbd_name="$rbd_name@${OCF_RESKEY_snap}"
  fi

  ocf_run rbd-nbd $rbdnbd_opts map $rbd_name || exit $OCF_ERR_GENERIC

  # After the resource has been started, check whether it started up
  # correctly. If the resource starts asynchronously, the agent may
  # spin on the monitor function here -- if the resource does not
  # start up within the defined timeout, the cluster manager will
  # consider the start action failed
  while ! rbdnbd_monitor; do
    ocf_log debug "Resource has not started yet, waiting"
    sleep 2
  done

  # udev rules should create a friendly name like
  # /dev/rbd-nbd/rbd/test@snap, wait for it
  while :; do
    ls /dev/rbd-nbd/${rbd_name} >/dev/null 2>&1 && break
    ocf_log debug "Waiting for udev to create symlink /dev/rbd-nbd/${rbd_name}"
    sleep 1
  done

  # only return $OCF_SUCCESS if _everything_ succeeded as expected
  return $OCF_SUCCESS
}

rbdnbd_stop() {
  local rc
  local nbd_dev

  rbdnbd_monitor
  rc=$?
  case "$rc" in
    "$OCF_SUCCESS")
      # Currently running. Normal, expected behavior.
      ocf_log debug "Resource is currently running"
      ;;
    "$OCF_NOT_RUNNING")
      # Currently not running. Nothing to do.
      ocf_log info "Resource is already stopped"
      return $OCF_SUCCESS
      ;;
  esac

  # After the resource has been stopped, check whether it shut down
  # correctly. If the resource stops asynchronously, the agent may
  # spin on the monitor function here -- if the resource does not
  # shut down within the defined timeout, the cluster manager will
  # consider the stop action failed
  while rbdnbd_monitor; do
    nbd_dev=$(get_nbd_info dev)
    rbd-nbd unmap $nbd_dev
    ocf_log debug "Resource has not stopped yet, waiting"
    sleep 2
  done

  # only return $OCF_SUCCESS if _everything_ succeeded as expected
  return $OCF_SUCCESS

}

rbdnbd_validate_all() {
  local version

  # Test for configuration errors first
  if [ -z "$OCF_RESKEY_name" ]; then
    ocf_log err 'Required parameter "name" is unset!'
    exit $OCF_ERR_CONFIGURED
  fi

  # Test for required binaries
  check_binary rbd-nbd

  version=$(rbd-nbd --version | cut -d' ' -f3)
  # This RA is only tested with Ceph Luminous
  ocf_version_cmp "$version" 12.2.0
  case $? in
    0) 
      ocf_log err "We do not support Ceph version $version, it is too old"
      exit $OCF_ERR_INSTALLED
      ;;
    [12]) ;; # we can work with versions >= 12.2.0
    3)
      ocf_log err "rbd-nbd produced version <$version>?!?"
      exit $OCF_ERR_INSTALLED
      ;;
  esac

  return $OCF_SUCCESS
}

# Make sure meta-data and usage always succeed
case $__OCF_ACTION in
  meta-data)  rbdnbd_meta_data
              exit $OCF_SUCCESS
              ;;
  usage|help) rbdnbd_usage
              exit $OCF_SUCCESS
              ;;
esac

# Anything other than meta-data and usage must pass validation
rbdnbd_validate_all || exit $?

# Translate each action into the appropriate function call
case $__OCF_ACTION in
  start)          rbdnbd_start;;
  stop)           rbdnbd_stop;;
  status|monitor) rbdnbd_monitor;;
  validate-all)   ;;
  *)              rbdnbd_usage
                  exit $OCF_ERR_UNIMPLEMENTED
                  ;;
esac
rc=$?

# The resource agent may optionally log a debug message
ocf_log debug "${OCF_RESOURCE_INSTANCE} $__OCF_ACTION returned $rc"
exit $rc
